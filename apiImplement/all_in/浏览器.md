# 1.输入url发生了什么

1. 首先会去判断是否有永久重定向(301)，如果有的话直接跳转到对应的URL

2. 接着会去查找强缓存，有则直接使用，如果是协商缓存则需要到服务器进行校验资源是否可用。强缓存通常有两个 HTTP 头进行控制，http1.0中用的是Expires，它是服务端提供的资源过期时间，由于是服务端的时间和客户端的时间可能不一致，所以这个字段没那么准确，还有就是在http1.1中，采用的是Cache-Control字段，通过max-age来设置，这个字段是资源的有效时间，因为它是绝对时间，所以相比较先前用expires来说，它更加准确。

3. 然后浏览器解析 URL获取协议，主机，端口，path，接着浏览器组装一个 HTTP（GET）请求报文

4. 接着由于我们输入的是域名，而数据包是通过IP地址传给对方的。因此我们需要得到域名对应的IP地址。这个过程需要依赖一个服务系统来将域名和 IP 一一映射，这个系统就叫做DNS。得到具体 IP 的过程就是DNS解析。并且浏览器提供了DNS数据缓存功能。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 DNS解析。如果不指定端口的话，默认采用对应的 IP 的 80 端口。

5. 拿到IP以后经过三次握手建立TCP连接。

   1. 客户端主动发起连接，发送SYN，自己变成了SYN-SENT状态，发送的为一个SYN请求，发送端的初始数据包序号为seq=x，**代表客户端有发送的能力**
   2. 服务端接收到，自己变成了SYN-RECEIVED。并返回一个SYN，序列号为seq=y，ack=x+1的响应包，每次发送SYN都要消耗一个序列号的，对应到对端发送的ack是在syn序列号的基础上加1。**此时证明了服务端具有发送和接收的能力**。当客户端知道了对端具有发送和接收能力的时候，自己的状态才变成ESTABLISHED状态
   3. 客户端再发送ACK(ack=y+1)给服务端，服务端收到ACK之后，**说明了客户端也具备接收能力**，所以服务端也变成了ESTABLISHED状态。

   + 可以携带数据吗？
     + 如果前两次握手能够携带数据， 那么一旦有人想攻击服务器， 那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据， 增大了服务器被攻击的风险。***第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据***
   + 为什么不是两次？
     + 因为如果没有第三次握手的话，无法确认客户端的接收能力。为了防止失效的连接请求报文段被服务端接收的情况，从而产生错误，因为此时如果客户端发送了一个连接请求 A， 但是因为网络原因造成了超时， 这时 TCP 会启动**超时重传**的机制再次发送一个连接请求 B。 此时请求顺利到达服务端， 服务端应答完就建立了请求， 然后接收数据后释放了连接。 假设这时候连接请求 A 在两端关闭后终于抵达了服务端， 那么此时服务端会认为客户端又需要建立 TCP 连接， 从而应答了该请求并进入 ESTABLISHED 状态。 但是客户端其实是 CLOSED 的状态， 那么就会导致服务端一直等待， 造成资源的浪费。
   + 为什么不是四次？
     + 三次握手的目的是确认双方发送和接收的能力，那四次握手可以嘛？当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。

6. TCP链接建立后，浏览器可以和服务器开始通信，发送HTTP请求。浏览器发送HTTP请求，HTTP请求主要包含三样东西，**请求行**GET / HTTP/1.1(请求方法是GET，路径为根路径，HTTP协议版本为1.1)，**请求头**，比如说**Cache-Control**、**If-Modified-Since**、**If-None-Match**都有可能被放入请求头中作为缓存的标识信息。最后是**请求体**，请求体只有在`POST`方法下存在，常见的场景是**表单提交**。

7. 紧接着HTTP 请求到达服务器后，服务器进行对应的处理，返回网络响应。网络响应一般包含**响应行**、**响应头**和**响应体**，响应行由`HTTP协议版本`、`状态码`和`状态描述`组成。**响应头**包含了服务器及其返回数据的一些信息， 服务器生成数据的时间、返回的数据类型以及对即将写入的Cookie信息。并且检查请求头中是否包含缓存验证信息，如果缓存资源有效的话，返回304等对应的状态码。网络响应到达浏览器后，TCP 连接根据connection决定是否断开，如果connection:keep-alive，则在有效期内他们使用同一条TCP连接。否则断开TCP连接，请求-响应流程结束。

   + HTTP无状态和connection:keep-alive
     + HTTP无状态：无状态协议是指http协议本身对于事务处理没有记忆功能，服务器不知道浏览器的状态。通俗的即使你登录了，去访问同一个网站的不同网页，服务器都不会知道你是谁，如果需要记录登录用户的信息，用户操作，用户行为等数据需要使用cookie或session来存储。
     + keep-alive：从HTTP/1.1起，浏览器默认都开启了Keep-Alive，保持连接特性，客户端和服务器都能选择随时关闭连接，则请求头中为connection:close。简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。但是Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。
   + Last-Modified和Etag
     + Last-Modified，即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。浏览器接收到后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间。服务器拿到请求头中的If-Modified-Since的字段后，
       其实会和这个服务器中该资源的最后修改时间对比，如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。
     + Etag，服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器。服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对。
     + 对比：
       + 在精准度上，ETag优于Last-Modified。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况。
         + 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
         + Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。
       + 在性能上，Last-Modified优于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而 Etag需要根据文件的具体内容生成哈希值。

8. TCP断开需要四次挥手🙋

   1. 首先客户端 A 需要向服务端 B 发送连接释放请求。
   2. B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。
   3. B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。
   4. A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。

   + 为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？
     + 被动方判断是否需要重传： 主动方发送的第一个ACK报文段，在网络中存活 1 MSL，
       因此被动方只要在1MSL时间单位内没接收到主动方的ACK报文段，就会重传FIN
     + 被动方重传：被动方重传的 FIN 报文段，在网络中最长存活时间也是 1MSL因此综上，
       只有主动方等待2个单位的MSL，才能确保可以收到被动方的重传FIN报文
   + ARQ协议：ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ 两种协议。
     + 只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。
     + 在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率

9. 浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同。如果资源可缓存，**进行缓存**。对响应进行**解码**（例如 gzip 压缩）。如果响应头中`Content-Type`的值是`text/html`，那么接下来就是浏览器的`解析`和`渲染`工作了。

10. 浏览器拿到源代码，然后分配一个线程，自上而下，从左向右依次解析和渲染代码

11. 构建DOM树。根据 HTML 规范将字符流解析为标记，词法分析将标记转换为对象并定义属性和规则，根据 HTML 标记关系将对象组成 DOM 树

12. 构建**CSSOM 树**。字符流转换为标记流，根据标记创建节点，根据节点创建 CSSOM 树。

13. 在构建DOM树以及CSSOM树的过程中。

    + 如果遇到link，link导入外部样式资源，浏览器会开辟一个新的线程，去服务器获取对应的资源文件(不会阻碍主线程的渲染)
    + 如果遇到@import导入样式，同步，此时不会开辟新的线程去加载资源文件，而是让主线程去获取，这样阻碍了DOM结构的继续渲染，只有把外部样式导入进来并且解析后，才会继续渲染DOM结构
    + 碰到script标签，主线程会从服务器获取到JS资源，并把JS资源进行解析加载，加载完成后再继续渲染DOM结构。如果想让script加载不会阻塞页面渲染，则需要加上属性。
      + script没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。
      + defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。**多个脚本按顺序执行。**
      + async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。**多个脚本的执行顺序无法保证。谁先获取到谁先执行**
    + DOMContentLoaded 事件和 Load 事件的区别？
      + DOMContentLoaded在DOM结构加载完成就会触发，DOM树有了，并且JS也执行加载了，触发这个事件，此时不一定能看到页面，还没有渲染到页面上
      + Load在资源都加载完才触发，包含了需要等待图片等资源也都加载完才触发，此时一定能看到页面

14. 根据 DOM 树和 CSSOM 树构建渲染树。从 DOM 树的根节点遍历所有**可见节点**，不可见节点包括：1）`script`,`meta`这样本身不可见的标签。2)被 css 隐藏的节点，如`display: none`，对每一个可见节点，找到恰当的 CSSOM 规则并应用

15. 然后根据生成的渲染树，计算它们在设备适口内的确切位置和大小(回流)，以及回流得到的几何信息，得到节点的绝对像素，最后将像素发送给GPU，展示在页面上。这其中对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生`回流`的过程。会又从DOM树构建那里走一遍，所以开销会非常大。当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致`重绘`(`repaint`)。由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。重绘不一定导致回流，但回流一定发生了重绘。

    + 回流
      + 一个 DOM 元素的几何属性变化
      + 使 DOM 节点发生`增减`或者`移动`
      + 读写 `offset`族、`scroll`族和`client`族属性的时候，浏览器为了获取这些值，需要进行回流操作。
      + 调用 `window.getComputedStyle` 方法。
    + 重绘
    + 合成：利用 CSS3 的`transform`、`opacity`、`filter`这些属性就可以实现合成的效果，也就是大家常说的**GPU加速**。在合成的情况下，会直接跳过布局和绘制流程，直接进入`非主线程`处理的部分，即直接交给`合成线程`处理。交给它处理有两大好处:
      + 能够充分发挥`GPU`的优势。合成线程生成位图的过程中会调用线程池，并在其中使用`GPU`进行加速生成，而GPU 是擅长处理位图数据的。
      + 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。
    + 实践意义
      + 元素批量修改createDocumentFragment
      + 缓存布局信息：需要多次改变的信息事先保存起来
      + 样式集中改变：渲染队列可以保证一次回流，多个导致回流的操作写在一起，浏览器会集中处理
      + 分离读写操作(现代浏览器都有渲染队列的机制)
      + CSS3硬件加速(GPU加速)，transform、opacity、filters......这些属性会触发硬件加速，不会引发回流和重绘
      + 对于 resize、scroll 等进行防抖/节流处理





# 2.浏览器安全

1. XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而拿到用户的信息并进行操作，如 cookie 等。XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。主要有以下类型：

   + ==存储型==：存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。

     常见的场景是留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中`直接执行`, 相当于执行一段未知逻辑的 JS 代码，是非常恐怖的。这就是存储型的 XSS 攻击。

   + ==反射型==：指的是恶意脚本作为**网络请求的一部分**。**通过 url 参数直接注入。发出请求时，XSS 代码出现在 URL 中，作为输入提交到服务器端，服务端解析后返回，XSS 代码随响应内容一起传回给浏览器，最后浏览器执行 XSS 代码。**反射型XSS攻击是一次性的，必须要通过用户点击链接才能发起，一些浏览器，如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击，反射型XSS其实就是服务器没有对恶意的用户输入进行安全处理就直接反射响应内容，导致恶意代码在浏览器中执行的一种XSS漏洞。`http://sanyuan.com?q=<script>alert("你完蛋了")</script>`

   + 反射型和存储型对比：反射型需要用户点击才能触发，危害相对较小。存储型是存储在了服务器中，不需要用户交互也能触发，危害更大

   + ==DOM型==：DOM型攻击不需要服务器端支持，是由于DOM结构修改导致的，基于浏览器DOM解析的攻击。
     用户打开带有恶意的链接，浏览器在DOM解析的时候直接使用恶意数据，常见触发场景就是在修改innerHTML outerHTML document.write的时候

   防范措施：

   + 千万不要相信任何用户的输入！无论是在前端和服务端，都要对用户的输入进行**转码**或者**过滤**。
   + 利用 CSP：CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击：限制其他域下的资源加载。禁止向其它域提交数据。提供上报机制，能帮助我们及时发现 XSS 攻击。设置 HTTP Header 中的 Content-Security-Policy。设置 meta 标签的方式 `<meta http-equiv="Content-Security-Policy">`
   + 利用 HttpOnly：很多 XSS 攻击脚本都是用来窃取Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。

2. CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

   比如黑客网页里面可能有一段这样的代码：

   ~~~html
   <img src="https://xxx.com/info?user=hhh&count=100">
   ~~~

   进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息(这里是假定你已经在 xxx.com 中登录过)。假如服务器端没有相应的验证机制，它可能认为发请求的是一个正常的用户，因为携带了相应的 cookie，然后进行相应的各种操作，可以是转账汇款以及其他的恶意操作。

   防范措施：

   + ==利用Cookie的SameSite属性==：`CSRF攻击`中重要的一环就是自动发送目标站点下的 `Cookie`,然后就是这一份 Cookie 模拟了用户的身份。

     + Strict：在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。
     + 在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。
     + 在None模式下，也就是默认模式，请求会自动携带上 Cookie

   + ==验证来源站点==：这就需要要用到请求头中的两个字段: **Origin**和**Referer**。其中，**Origin**只包含域名信息，而**Referer**包含了`具体`的 URL 路径。当然，这两者都是可以伪造的，通过 Ajax 中自定义请求头即可，安全性略差。

   + ==CSRF Token==：浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。

     然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。这个字符串也就是`CSRF Token`，通常第三方站点无法拿到这个 token, 因此也就是被服务器给拒绝。





# 3.防抖与节流

1. 防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

   ~~~JS
   function debounce(fn, delay) {
     // 定时器
     let timer = null;
     // 将debounce处理结果当作函数返回
     return function (...args) {
       // 保留调用时的this上下文
       let context = this;
       // 每次事件被触发时，都去清除之前的旧定时器
       if (timer) clearTimeout(timer);
       // 设立新定时器
       timer = setTimeout(function () {
         fn.apply(context, args);
       }, delay);
     }
   }
   
   // 用debounce来包装scroll的回调
   const better_scroll = debounce(() => console.log('触发了滚动事件'), 1000)
   
   document.addEventListener('scroll', better_scroll)
   ~~~

   + 实现输入间隔大于某个值（如500ms），就当做用户输入完成，然后开始搜索，具体使用哪种方案要看业务需求。

2. 节流：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

   ~~~JS
   const throttle = (fn, delay = 500) => {
     let flag = true;
     return (...args) => {
       if (!flag) return;
       flag = false;
       setTimeout(() => {
         fn.apply(this, args);
         flag = true;
       }, delay);
     };
   };
   ~~~

   + 搜索框input事件，例如要支持输入实时搜索可以使用节流方案（间隔一段时间就必须查询相关内容）
   + 抢券时疯狂点击，既要限制次数，又要保证先点先发出请求(节流)
   + 窗口调整
   + 页面滚动

~~~JS
//throttle来优化debounce
//如果用户的操作十分频繁——他每次都不等 debounce 设置的 delay 时间结束就进行下一次操作，
//于是每次 debounce 都为该用户重新生成定时器，回调函数被延迟了不计其数次。
//频繁的延迟会导致用户迟迟得不到响应，用户同样会产生“这个页面卡死了”的观感。

// fn是我们需要包装的事件回调, delay是时间间隔的阈值
function throttle(fn, delay) {
  // last为上一次触发回调的时间, timer是定时器
  let last = 0,
    timer = null
  // 将throttle处理结果当作函数返回

  return function () {
    // 保留调用时的this上下文
    let context = this
    // 保留调用时传入的参数
    let args = arguments
    // 记录本次触发回调的时间
    let now = +new Date()

    // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值
    if (now - last < delay) {
      // 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器
      clearTimeout(timer)
      timer = setTimeout(function () {
        last = now
        fn.apply(context, args)
      }, delay)
    } else {
      // 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应
      last = now
      fn.apply(context, args)
    }
  }
}
~~~

