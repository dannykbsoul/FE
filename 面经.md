字节面试题准备：

+ 关于数据类型转换的规则
+ 异步 cb=>iterator=>generator=>promise=>async、await
+ 柯里化 compose类型题



准备好合适的问题问面试官：

+ 整个小组的大概运行模式是怎样的
+ 整个项目的后续规划是如何的
+ 为什么会选择某些技术？标准？
+ 我对某个技术很感兴趣，在你的小组中我会有怎么样的机会深入

京东日常：

+ 双向数据绑定原理
+ vue3.0新特性以及为什么用这个新特性，为什么升级
+ http2新特性 tcp udp区别
+ webpack有没有配过
+ js轮询机制 js下和node环境下
+ treeshaking原理
+ http状态码



目前已投递

+ 360  笔试3.25 一面挂
+ 奇安信 笔试3.28
+ 平安科技 简历不通过
+ 成都超有爱 笔试
+ 虎牙 
+ 商汤科技
+ 深圳锐明
+ 百度 3.29笔试 二面结束
+ 网易互联网 云音乐 3.31一面 挂
+ 网易雷火 4.25(1:00-2:30) 面试时间 5.9 放弃
+ 蘑菇街
+ 网易互娱 笔试
+ 美团 4.23笔试 5.6 11点
+ 京东 笔试 4.18 过
+ 小米 4.16投递
+ 快手 5.2前测评 笔试 4.26(4:00-6:00)
+ 拼多多 放弃面试

暂时不急着投递的

+ 跟谁学
+ 头条 
+ 爱奇艺
+ 陌陌 4.30
+ 携程
+ 作业帮
+ 招银网络
+ 深信服
+ oppo
+ 酷家乐
+ 百度日常实习
+ 顺丰



## 面经

网易云音乐一面：

+ 语义化标签
+ position取值 relative的作用
+ flex布局 alian-self
+ 发布订阅模式
+ 父子组件传值
+ 树的前序遍历 递归非递归
+ var let const
+ event loop
+ webpack中js用啥loader
+ location history
+ 深拷贝 浅拷贝
+ 数据类型
+ 原型
+ 盒模型
+ call、apply、bind
+ 介绍下Object.defineProperty()
+ 生命周期 以及 组件更新调用哪个



360 一面：

+ html语义化 自己用过哪些语义化标签
+ 选择器 以及优先级 组合
+ 数组去重 sort事件复杂度
+ var let const
+ symbol 遍历的方法
+ 遍历对象的方法
+ flex布局中margin实现水平垂直居中
+ 水平垂直居中
+ 三角形
+ 变量提升 var function等
+ 绑定事件的方法 如何解绑事件
+ js数据类型
+ symbol的创建和其他类型创建的区别
+ 状态码
+ 伪类、伪元素 有哪些状态
+ 数组常用实例方法 splice参数问题



百度：

一面：

+ 说一下doctype 都用过哪些doctype

+ 说下promise，async await
+ xss csrf xss有哪些攻击方式 csrf如何避免cookie携带 如何设置让前端通过js的方式拿不到cookie，cookie是前端生成的吗
+ 三栏布局 左右100px，中间自适应
+ 状态码
+ 缓存
+ 递归 说下如何优化
+ 闭包 以及缺陷
+ 用过哪些loader，给你个scss文件如何配置webpack，用过url-loader吗？是干嘛的 babel-loader是干嘛的
+ js垃圾回收机制
+ linux指令 复制一个文件到另一个
+ 说下git的指令
+ 说一下继承 class new发生了啥
+ 如何判断对象是空 如何获取到对象的属性
+ 说一下slice splice
+ 实现拖拽窗口
+ 如何清除浮动
+ BFC 如何创建BFC
+ 说一下模块化
+ em和rem
+ call、apply、bind的区别

二面：

+ 大数相加 有正、负数呢
+ 节流
+ 实现一个圆形，四等分，左上角和右下角颜色灰色
+ float有了解吗 float的兼容性了解
+ 说下position
+ 请求重试，如果请求失败三次给提示
+ 为啥选vue，不选jquery，为啥有vuex，带来哪些好处 说一下view modal层是干嘛的

京东一面：

+ 水平垂直居中
+ css实现动画
+ js创建类，对象以及继承
+ position
+ float的用处以及如何清除浮动
+ 雪碧图以及雪碧图中用到的定位、属性
+ 什么是跨域？如何解决跨域问题
+ 箭头函数和普通函数的区别
+ promise
+ 实现一个模板方法，作用类似于ES6的==``==，例如：`template('我是${name}, 今年${age}岁', {name: 'Tom', age: 18}) 返回 '我是Tom, 今年18岁'`
+ js实现浅拷贝 类似于Object.assign(obj1,obj2,[…]) extend(obj)
+ vue组件通信
+ vue key的作用
+ 你如何学习前端的

京东二面：

+ 介绍下项目
+ 说下vuex的好处在项目中
+ 组件化模块化在项目中的用处
+ 双向绑定
+ vue3.0改进之处
+ http2.0
+ 继承
+ this

京东hr面：

+ 自我介绍
+ 说一下实验室的项目
+ 怎么做的？学到了什么？后面觉得还能改进吗？
+ 为什么选择前端？如何自学？
+ 职业规划
+ 优缺点
+ 为什么选择jd？
+ 啥时候能实习？
+ 反问



# 1.缓存

浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求，那么
浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识，分为三种情况：

1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求

2. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存，那么此时浏览器会携带该资源的缓存标识，向服务器发送请求，如果此时服务端返回304，协商缓存生效，说明该资源无更新，那么可以直接去浏览器缓存中获取该请求的结果；如果服务端返回200，协商缓存失效，此时会将该请求的返回结果和缓存标识存入浏览器缓存中。

    控制协商缓存的字段主要有Last-Modified / If-Modified-Since和Etag / If-None-Match。Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。

    Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。

    Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。

3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果。控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。但是也有一定的缺点，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。

    到了HTTP/1.1，Expire已经被Cache-Control替代，Cache-Control的取值主要有：

    - public：所有内容都将被缓存（客户端和代理服务器都可缓存）
    - private：所有内容只有客户端可以缓存，Cache-Control的默认取值
    - no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
    - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
    - max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

    **HTTP响应报文中expires的时间值，是一个绝对值，HTTP响应报文中Cache-Control为max-age=600，是相对值**，所以在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。

    强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存。

# 2.跨域

协议、域名、端口相同的为同源。

同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。**是浏览器做的努力**

主要限制在几个方面

- Cookie、LocalStorage 和 IndexDB 无法读取
- DOM 无法获得
- AJAX 请求不能发送

前后端如何通信：

+ ajax
+ websocket
+ cors



# 3.http和https

http是超文本传输协议，是一个应用层的协议，由请求和响应构成。http的特点是无状态，http通信过程会有请求报文和响应报文，请求报文中有请求行、请求头、空行、请求体组成，请求行主要是由请求方法、请求资源地址和协议版本组成，请求头主要是一些服务器要使用的附加信息，比如说user-agent、 accept、content-type、connection、if-none-match、if-modified-since等，请求体就是一些需要传输的数据。响应报文中主要有状态行、响应头、响应体，状态行主要就是状态码、状态信息和协议版本号，响应头主要是一些客户端需要用到的附加信息，如content-type、last-modified、expires、etag等，响应体是返回给客户端的文本信息。

请求方法主要有get、post、put、delete、head，get和post的主要区别有

从用法来说Get一般用于无副作用、幂等的场景；Post多用于有副作用、不幂等的情况

> 冥等的定义：发送M和N次请求，服务器上资源状态一致。比如说，注册10个账号和11个账号是不冥等的，对文章进行了10次11次修改是幂等的，因为前者多了一个账号（资源），后者是更新同一个资源。
>
> 副作用的定义：副作用是指对服务器上资源做改变。比如搜索是无副作用的，但更新是有副作用的。

+ get请求能缓存，post不行
+ GET在浏览器回退时是无害的，而POST会再次提交
+ post比get相对安全一点，因为get请求的信息都是包含在url中，而且会被浏览器记录
+ Post 可以通过 request body来传输比 Get 更多的数据
+ URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的
+ Post 支持更多的编码类型且不对数据类型限制

常见的状态码有

100 表示服务器收到了请求的初始部分，并且请客户端继续发送。

200 表示服务器成功处理了请求并返回资源，204表示服务器成功处理了请求，但是没有数据，这个状态通常是cors预检发送options请求以后，服务端返回的状态码。

301 表示资源永久性重定向，当浏览器收到的HTTP状态码为301时，下次访问对应网址就直接调整到新的网址，不会再访问原网址，302 是临时重定向，浏览器每次访问都要先去目标网址访问，再重定向到新的网址，304 自从上次请求后，请求的网页未修改过，请客户端使用本地缓存。 服务器返回此响应时，不会返回网页内容。

400 服务器不理解请求的语法，401 未授权，请求要求身份验证，对于那些需要登陆的网页，服务器会返回此响应，403 表示服务器拒绝请求，404 表示服务器上没有找到请求的资源。

500 表示服务端在执行请求时发生了错误，503 表示服务器目前无法使用（由于超载或停机维护）

http是采用请求响应的模式，并且http是基于tcp连接的，普通模式时，每一次的请求响应都需要建立一次连接，完成之后断开。当使用keep-alive，那么客户端与服务端的连接持续有效，即不关闭底层的tcp连接，当出现对服务端的后继请求时，keep-alive避免了重新连接建立和释放的开销。但是，长时间的TCP连接容易导致系统资源无效占用，配置不当的keep-alive有时比重复利用连接带来的损失还更大。所以，正确设置keep-alive timeout时间非常重要。

http/1.1有了长连接，在此之上产生了管线化，即请求和响应就可以不再是依次交替的了。他可以支持一次性发送多个请求，并一次性接收多个响应。

- 管线化机制通过持久连接完成，仅HTTP/1.1支持此技术

- 只有get与head请求可以进行管线化，POST有限制
- 初次创建连接时不应该启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议
- 管线化不会影响响应到来的顺序，即响应返回的顺序并未改变



http2.0是对http1.0的改进，相较于http1.0更快更高效

1. http2.0实现了**多路复用**，用**一个TCP进行连接共享，一个请求对应一个id，这样就可以发送多个请求**，接收方通过id来响应不同的请求，解决了http1.0队首阻塞和连接过多的问题。因为http2.0**在同一域名不论访问多少文件都只有一个连接**，所以对服务器而言，提升的并发量是很大的。

2. http2.0引入了**二进制数据帧和流**的概念，**数据拆分成数据帧传输，并进行顺序标识，接收方收到数据后按序组合即可获取正确数据**。这样就可以**并行**传输了，解决了http1.0只能串行传输的问题。

3. http2.0**压缩头部**，使**用序号对头部编码，在两端备份索引表，通过对编码进行比较来判断是否需要传输，减少了需要传输的大小**。解决了http1.0中头部反复传输资源浪费的问题

4. http2.0中，服务器可以在客户端某个请求后，**主动推送一些客户端一定需要的资源** 。这样也能减少请求的数目。

当然http2.0也不是尽善尽美的，比如说在出现丢包的情况时，需要重新传输，后面的数据也就被阻塞了，但是http1.0因为有多个连接，所以不会影响其他连接的传输。这样的话http2.0的性能反倒不如http1.0了。



http和https

1. http是超文本传输协议，信息是明文传输的，https则是具有安全性的ssl加密传输协议
2. 端口不一样，http 80，https 443
3. http连接是无状态的，https协议是由tls协议进行了加密，比http协议安全
4. https协议需要ca申请证书

tls作用于表示层

https同时使用了对称加密和非对称加密，（对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据，非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。）数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，**对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输**。

一个HTTPS请求实际上包含了两次HTTP传输，具体流程主要是：

1. 客户端向服务器发起HTTPS请求，连接到服务器的443端口
2. 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
3. 服务器将自己的公钥发送给客户端。
4. 客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
5. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7. 然后服务器将加密后的密文发送给客户端。
8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。



http是无状态的协议，怎么记录登录状态？

- cookie:服务器通过设置`set-cookie`这个响应头，将cookie信息返回给浏览器，浏览器将响应头中的cookie信息保存在本地，当下次向服务器发送HTTP请求时，浏览器会自动将保存的这些cookie信息添加到请求头中。通过cookie，服务器就会识别出浏览器，从而保证返回的数据是这个用户的。 
- session:session典型使用场景购物车，session基于cookie实现的。存放在服务器的一种用来存放用户数据的类似HashTable的结构。浏览器第一次发送请求时，服务器自动生成了HashTable和SessionID来唯一标识这个hash表，并将sessionID存放在cookie中通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的sessionID随着cookie发送到服务器上，服务器从请求中提取sessionID，并和保存的所有sessionID进行对比，找到这个用户对应的hash表。
- token:常用在接口校验，是服务端生成一串字符串，作为客户端请求的标识，用户第一次登陆后，服务器生成一个token并将token返回客户端，以后客户端只需要带着token请求数据，无需用户名密码。 
- token具体:客户端使用用户名和密码请求登录。服务端收到请求，验证用户名和密码。验证成功后，服务端会生成一个token，然后把这个token发送给客户端。客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。客户端每次向服务端发送请求的时候都需要带上服务端发给的token。服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据。



# 4.性能优化

1.第一个是webpack的优化，一般来说webpack优化从俩方面入手，减少webpack的打包时间和让webpack打包出来的文件体积更小。

打包后的体积主要通过按需加载、tree shaking、scope hoisting的方式来缩小。

+ 如果说将页面全部打包到同一个js文件中，虽然说是请求合并了，但是同样也加载了很多不必要的代码，为了让用户首屏的体验更好，肯定是首屏加载的文件体积越小越好，那么我们可以按需加载，将每个路由页面单独打包为一个文件。
+ 还有就是我们打包的时候，会把引用的模块整个打包，但是我们可能只用到了模块的一部分，所以用tree shaking可以把模块中我们用不到的shaking掉，webpack4在生产环境下默认开启了tree shaking，开发环境下要在optimization下配置usedExports：true，当然为了避免一些tree shaking带来的影响，我们可以在package.json中配置sideEffects来说明不需要tree shaking的模块。
+ optimization中配置concatenateModules: true，可以让webapck分析出模块之间的依赖关系，尽可能打包出来的模块合并到一个函数中'

打包的时间主要通过loader、happypack、dllplugin来优化

+ 我们在尽可能的少的模块上应用loader，可以在rule中include exclude来优化文件搜索范围，比如说我们可以不用编译node_modules中的模块，因为里面都是打包编译过的。这样的话可以加快打包的速度
+ 我们还可以将打包编译过的文件缓存起来，下次只需要编译更改后的代码文件即可，`loader: 'babel-loader?cacheDirectory=true'`
+ 我们可以给需要打包的文件名加上占位符contenthash，在打包文件内容有变化时，`contenthash`值会自动变化。当项目重新打包上线的时候，用户只需要更新有变化的代码，而没有变化的直接用本地的缓存
+ 另一方面，受限于node是单线程的，所以webpack打包也是单线程的，特别是在执行loader的时候，长时间编译的任务很多，这样就会导致等待的情况。HappyPack可以将Loader的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了
+ 还有就是我们可以通过dllplugin将特定的类库提前打包引入，这样可以极大的减少打包类库的次数，只有类库版本更新了，才需要重新打包。公共代码抽离成单独文件，在webpack.dll.js下对第三方模块单独进行打包，并且通过dllreferenceplugin将依赖文件引入项目中

还有就是一些其他小的优化点就是，合理的利用sourceMap，开发模式建议用`cheap-module-eval-source-map`，提示出来的错误比较全面，同时打包速度也比较快；在生产模式建议用`cheap-module-source-map`，带`inline`*与*`eval`的不能用于生产环境是因为这两者生成的SourceMap是内嵌在构建完成的js代码中的，会在生产环境直接暴露源代码。

开发环境内存编译。开发环境我们用的webpackDevServer，打包的时候不会生成dist目录，而是将编译生成的文件放到内存中，内存的读取肯定要比硬盘的读取快的多，从而提高开发环境下webpack打包的性能。

resolve.extensions用来表明文件后缀列表，默认查找顺序是 ['.js', '.json']，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面。长度很长的话，意味着每一次查找都需要调用一次文件查找，很影响性能。

resolve.alias可以通过别名的方式来映射一个路径，能让Webpack更快找到路径。

2.网络方面

合并资源请求，减少http请求，因为浏览器发送http请求是有数量限制的，如果一下子发出很多请求，那么后面的请求会等待前面的请求，这样会延长整个页面的加载时间，比如说雪碧图就是将小图标和背景图像合并到一张图片上，然后利用CSS的背景定位来显示其中的每一部分，使得使用一个图像文件替代多个小文件成为可能，减少了http请求次数。还有就是以Base64编码的形式直接写在html中，浏览器会识别图片，这样可以不用发送http请求，但是大小有限制。

还有就是压缩资源文件大小，可对代码进行压缩，去掉空格、注释、变量替换，在传输时，使用gzip等压缩方式也可以降低资源文件的大小。

利用缓存机制，尽可能使用缓存减少请求。

**面对一个具体的缓存需求时，我们到底该怎么决策呢？**

![4](/Users/dannysoul/Desktop/4.png)

当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。



dns prefetch，当你浏览网页的时候，浏览器会在加载网页时对网页中的域名进行解析缓存，当你点击网页中的链接时就无需进行dns解析，减少用户等待时间，提高用户体验。还有就是cookie的优化，如果在进行同域名的资源请求时，浏览器会默认带上本地的cookie，这就会带来很大的负担，比如说一个页面加载，会请求很多静态资源，那每一个静态资源的请求都会带上cookie，事实上静态资源并不需要cookie验证。那么我们可以用多域名拆分的方式，将静态资源放在cdn域名下，并且考虑到单个域名有并发请求上限，可以考虑使用多个cdn域名，并且对于CDN加载静态资源需要注意CDN域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载，但不执行，在需要执行的时候执行。当浏览器发现自己需要这些资源时已经为时已晚，所以大多数情况，这些资源的加载都会对页面渲染造成延迟。

可以通过预渲染将下载的文件预先在后台渲染，但是要确保该页面要100%被打开，否则白白浪费了资源。

最好使用http2.0，因为1.0的时候，每个请求都要重新建立和断开，并且由于tcp慢启动的原因，加载体积大的文件很耗时，那么在2.0中引入了多路复用，能够让多个请求使用一个tcp连接，而且支持header压缩，进一步缩小了请求数据的大小

3.浏览器渲染方面

因为浏览器的渲染过程是，浏览器从网络或者磁盘去读取html原始字节，并根据文件的编码形式转换成字符串，然后将字符串转换成token，这些token会标记出当前的token是开始标签还是结束标签，根据这些token创建dom节点对象，从而生成了dom树，cssom树的构建和dom树的构建相似，这俩个过程是并行的，然后dom树和cssom树结合，生成渲染树，接着从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标，得到了基于渲染树的布局渲染树，最后再绘制渲染树，这样页面的初次渲染就完成了。之后每当添加新元素到dom树上，浏览器都要通过css引擎查找css样式表，找到符合该元素的样式规则应用到这个元素上，然后再重新去绘制它，查找样式表的规则是从右向左的，所以在写css选择器的时候，应该尽量考虑到css引擎的方便。

- 避免使用通配符，只对需要用到的元素进行选择。
- 少用标签选择器。
- 减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低



渲染过程中遇到`<script>`就停止渲染，执行js代码，因为浏览器中有gui渲染线程和js引擎线程，为了防止渲染过程中出现不可预期的结果，这俩个线程是互斥的关系。js的加载执行和解析会阻塞dom的构建，所以说如果想要首屏速度快的话，script标签最好放在底部。同样css也会阻塞渲染，就算dom树构建完成，也要等到cssom树构建完成才能开始渲染，所以一般情况下将CSS放在 head 标签里，是为了尽早的构建cssom树。

由于CSS不会阻塞文档的解析，但是会阻塞文档渲染。把CSS放在头部可以先生成CSSOM树，后续渲染DOM的时候，可以一次性构建Render树，只需要渲染一次；如果把CSS放在后面，会先解析一次DOM，加载CSS之后，会重新渲染之前的DOM，需要两次渲染。

- DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片...
- load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已加载完成

我们可以通过给script标签设置加载模式来解决js阻塞的问题

+ 正常模式下js会阻塞浏览器
+ async js不会阻塞浏览器，它的加载是异步的，当加载结束，js会立即执行
+ defer js加载也是异步的，当整个html解析完成，DOMContentLoaded即将被触发时，js才会开始执行

一般来说脚本和dom元素之间的依赖性不强的时候，用async，如果脚本依赖于dom元素和其他脚本的执行结果时，用defer

4.dom优化

js修改dom可能会造成回流和重绘

当我们对dom的修改引发了dom几何尺寸的变化（修改宽、高、隐藏元素），浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来，这就叫做回流。

当我们对dom的修改导致了样式的变化，却未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，叫做重绘。

可以看出重绘不一定导致回流，但是回流一定导致重绘。

比如说想往div中写入10000句一样的话，使用document.createDocumentFragment()的虚拟节点对象先把要添加进页面的节点先存起来，然后一次性加到dom树里，这样避免了重复的添加导致的回流，很影响性能。

如何避免回流重绘制：

### CSS

- 避免使用`table`布局。
- 尽可能在`DOM`树的最末端改变`class`。
- 避免设置多层内联样式。
- 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上。
- 避免使用`CSS`表达式（例如：`calc()`）。

### JavaScript

- 避免频繁操作样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。
- 避免频繁操作`DOM`，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。
- 也可以先为元素设置`display: none`，操作结束后再把它显示出来。因为在`display`属性为`none`的元素上进行的`DOM`操作不会引发回流和重绘。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。



懒加载是针对图片加载时机的优化，在一些图片量比较大的网站，用户打开页面的时候，如果一次性把这个页面所有的图片资源加载完，那么很可能会造成白屏、卡顿的现象，但其实给用户展示的只是一部分，所以可以先把首屏的资源加载完，后面的资源等用户下拉再去请求加载，这样的称为懒加载。



节流和防抖

这两个东西都以**闭包**的形式存在。它们通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，最后用setTimeout来控制事件的触发频率。



# 5.tcp和udp



# 6.输入url



# 7.JS

##new关键字

创建一个全新的对象，这个对象的__proto__指向构造函数的prototype属性，将构造函数的this替换成新的对象并执行。

##观察者模式和发布订阅模式

发布者直接能触及到订阅者的操作，叫观察者模式，而发布订阅模式，发布者和订阅者是由统一的第三方来完成通信。eventemitter，on用来订阅事件，并传入回调函数，emit触发

##深浅拷贝

浅拷贝只会将目标对象的各个属性进行一次复制，但不会递归复制，如果说目标对象第一层为基本数据类型的值，那么就会直接赋值，如果说是引用数据类型的话，那么会直接复制栈内存中的堆内存地址。

深拷贝不只拷贝目标对象的第一层，而是递归拷贝目标对象的所有属性

JSON.stringfy()，所有安全的JSON值，都可以用stringfy字符串化，不安全的JSON值。undefined、function、symbol和包含循环引用的对象。无法拷贝一些`特殊的对象`，诸如 RegExp, Date, Set, Map等。

1. 他无法实现对函数 、RegExp等特殊对象的克隆
2. 会抛弃对象的constructor,所有的构造函数会指向Object
3. 对象有循环引用,会报错

## 闭包

闭包是指有权访问另外一个函数作用域中的变量的函数，产生的原因主要是即使创建它的上下文已经销毁，但是它依旧可以通过作用域链存在，当前环境中存在指向父级作用域的引用。

稀疏数组是指 **索引不连续，数组长度大于元素个数的数组**，通俗地说就是 **有空隙的数组**。

转化为密集数组

```js
// 稀疏数组
var a = new Array(5);

Array.apply(null, a);    // ES5
Array.from(a);           // ES6
```



## 原型和原型链

js中，每定义一个函数数据类型，都自带prototype属性，这个属性指向函数的原型对象，当函数被new调用时，这个函数就成了构造函数，返回一个实例对象，这个实例对象有一个`__proto__`属性，它指向了构造函数的原型对象。

每个对象都可以有一个原型_proto_，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找，这样的一条路径就是原型链。



## 继承

1. 原型链继承：将子类构造函数的prototype指向父类的实例对象。

    缺点：因为子类只进行了一次原型修改，所以子类的所有实例都是指向同一父类的值，父类上的引用类型值被所有实例共享，并且在创建子类的时候，不能向父类型的构造函数传递参数。

2. 借用构造函数继承： 在子类构造函数中，使用`父类.call(this)`的方法继承父类属性，相当于在子类的构造函数中将父类构造函数执行一下

    缺点：子类无法继承父类原型链上的属性和方法，并且由于方法在构造函数中定义，每次创建实例都会执行一遍方法

3. 组合继承：使用原型链继承挂在父类原型上的各属性和方法，通过借用构造函数继承写在父类构造函数中this上绑定的各属性和方法

    缺点：调用了俩次父类构造函数，造成了不必要的损耗

4. 原型式继承：其实就是ES5 Object.create的实现，将传入的参数作为创建的对象的原型。

    缺点：包含引用类型的属性值始终会被共享，和原型链继承一样。

5. 寄生式继承：创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。

    缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。

6. 寄生组合式继承：让子类构造函数的prototype指向父类构造函数的prototype，但是有缺陷

    因为如果我想在子类的prototype上添加属性的话，会直接去父类的prototype上添加属性，使用Object.create()，其实就是让子类prototype和父类prototype中间隔一层对象，子类prototype指向这个对象，这个对象的`__proto__`指向父类的prototype。

    优点：只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。

    ~~~JS
     function Parent5 () {
        this.name = 'parent5';
        this.play = [1, 2, 3];
      }
      function Child5() {
        Parent5.call(this);
        this.type = 'child5';
      }
    //1. 这一步不用Child.prototype =Parent.prototype的原因是怕共享内存，修改父类原型对象就会影响子类
    //2. 不用Child.prototype = new Parent()的原因是会调用2次父类的构造方法（另一次是call），会存在一份多余的父类实例属性
    //3. Object.create是创建了父类原型的副本，与父类原型完全隔离
      Child5.prototype = Object.create(Parent5.prototype);
      Child5.prototype.constructor = Child5;
    ~~~

## 类数组对象

拥有一个length属性和若干索引属性的对象

+ 用getElementsByTagName/ClassName()获得的HTMLCollection
+ 用querySelector获得的nodeList

类数组转数组：

+ Array.prototype.slice.call()

+ Array.from()

+ ES6展开运算符 `let args = [...arguments];`

+ 利用concat+apply

    ~~~JS
    function sum(a, b) {
      let args = Array.prototype.concat.apply([], arguments);//apply方法会把第二个参数展开
      console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦
    }
    sum(1, 2);//3
    ~~~



## 数组中的高阶函数

map

参数:接受两个参数，一个是回调函数，一个是回调函数的this值(可选)。其中，回调函数被默认传入三个值，依次为当前元素、当前索引、整个数组。返回一个新的数组。

reduce

参数: 接收两个参数，一个为回调函数，另一个为初始值。回调函数中三个默认参数，依次为积累值、当前值、当前索引、整个数组。

filter

参数: 一个函数参数。这个函数接受一个默认参数，就是当前元素。这个作为参数的函数返回值为一个布尔类型，决定元素是否保留。filter方法返回值为一个新的数组，这个数组里面包含参数里面所有被保留的项。

sort

参数: 一个用于比较的函数，它有两个默认参数，分别是代表比较的两个元素。

~~~JS
let nums = [2, 3, 1];
//两个比较的元素分别为a, b
nums.sort(function(a, b) {
  if(a > b) return 1;
  else if(a < b) return -1;
  else if(a == b) return 0;
})
~~~

当比较函数返回值大于0，则 a 在 b 的后面，即a的下标应该比b大。

## this

this代表函数调用相关联的对象，如果此时作为函数直接调用，非严格模式下，this指向window，严格模式下指向undefined，作为某对象的方法调用时，this指向调用的对象，使用call/apply/bind可以显式绑定this，构造函数中，this指向新创建的对象，因为箭头函数没有this，所以箭头函数的this指向当前最近的非箭头函数的this。

优先级：new>call、apply、bind>对象.方法>直接调用

多次bind，this的指向永远由第一次bind所决定。

## promise

回调函数=>promise=>co+generator利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。=>async+await

node中回调函数的机制，发布订阅模式

promise为啥解决了回调地狱？

什么是回调地狱：1.多层嵌套的问题 2.每种任务的处理结果存在两种可能性，那么需要在每种任务执行结束后分别处理这两种可能性。

promise利用了三大技术解决了问题：1.回调函数延迟绑定 2.返回值穿透 3.错误冒泡

## 生成器

生成器是一个带*的函数，可以通过yield关键字暂停执行和恢复执行。

这种暂停执行恢复执行的实现机制主要靠协程，一个线程一次只能执行一个协程，比如说当前执行的A协程，另外还有一个B协程，如果想要执行B，那么就必须在A中将js线程的控制权转交给B，此时B执行，那么A就处于暂停状态。协程不是靠操作系统控制的，所以没有进程线程上下文的开销，这是高性能的重要原因。

thunk函数 这个函数接收一定参数，生成定制化的函数，使用定制化的函数去完成功能。



## js执行机制

当js遇到可执行代码（全局代码、函数代码、eval代码）的时候，会创建执行上下文，并压入执行上下文栈

js引擎先会执行全局代码，创建全局上下文，全局上下文被压入执行上下文栈中，每个执行上下文都会有三个重要的属性：变量对象、作用域链、this，一个执行上下文会分为两个阶段，`创建阶段`和`代码执行阶段`，在`创建阶段`，执行上下文会分别创建

1.变量对象：这里的变量对象主要是函数的所有形参（由名称和对应值组成的一个变量对象的属性被创建没有实参，属性值设为 undefined），函数声明，以及变量的声明，在执行阶段会顺序执行代码，根据代码，修改变量对象的值。

2.作用域链：函数的作用域在函数定义的时候就决定了，函数内部有个scope属性，是所有父变量对象的层级链，但是此时的scope并不是完整的作用域链，当函数执行时，进入函数上下文，创建vo/ao对象后，就会将ao添加到作用域链的前面，这时候的作用域链是完整的。

this的指向是在代码执行阶段确定的，默认情况下this指向全局对象，比如浏览器中的window，此外可能存在隐式绑定的情况，比如通过对象调用函数，然后就是显示绑定对象（call apply bind）等，最后优先级最高的就是new调用构造函数生成一个对象。





## 事件轮询

event loop是浏览器或`Node`的一种解决`javaScript`单线程运行时不会阻塞的一种机制，也就是我们经常使用**异步**的原理。

主要是通过一个执行栈和事件队列完成，首先是在执行栈执行全局代码，当遇到诸如setTimeout、setInterval、I/O、UI交互事件、setImmediate(Node.js 环境)这些宏任务时，会将这些放入宏任务任务队列中，当遇到process.nextTick、new Promise().then(回调)这些微任务的时候，会将这些放入微任务队列，当执行栈中每执行完一个宏任务，都会去执行微任务队列中的所有微任务，然后再去宏任务队列中去取一个宏任务放入执行栈中，执行宏任务。

node.js中，

1.先执行全局script代码，执行微任务

2.先执行nextTick queue中的微任务，再执行其他微任务

3.开始执行宏任务，总共6个阶段，从第一个阶段开始执行相应每一个阶段macrotask中的所有宏任务

4.Timers Queue -> microtask Queue ->I/O Queue -> microtask Queue -> Check Queue -> microtask Queue -> Close Callback Queue -> microtask Queue -> Timers Queue……

timers会执行setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。



## 异步的总结

js的异步其实是为了解决浏览器单线程问题而提出的，如果没有异步，那么浏览器在发送请求的时候就会一直卡死在等待服务器response上，从而造成资源利用地下的问题。而异步就是为了解决这个问题，而最早应用的异步应该就是ajax里面的回调函数了，但是回调函数依然有问题，那就是如果需要多次应用callback就要在里面一层层的添加回调函数从而而造成回调地狱，又或者是如果在多个ajax执行完成时才能执行下一步，那可能就需要添加许多额外的变量或者判断。而到了es6异步才算是真正的诞生。

首先是promise，很好了解决了`回调地狱`的问题，以链式调用的方式避免了大量的嵌套，promise函数可以说是现在应用的最多的一个函数了，我们在平时的开发请求中，也基本会用到它，首先我们知道的是promise其实有3个状态pending、fullified、reject，3种状态，而3种状态的转换是不可逆的，promise的首个状态一般是pending也就是在new Promise的时候传递进去的函数参数所在的状态就是pending，要知道的一个点是从pending到fullified状态其实是需要调用resolve参数的，而如果从pending到reject状态到达的路径有两条，函数内有语法或者数据导致报错，另一条就是手动调用reject，但是我们有一点需要注意的，对于promise的报错是逐渐冒泡的，比如我在promise函数内报错，那这个错误就会一直向下冒泡，经历所有的then直到后续有then的第二个参数或者catch对其进行捕获，如果没有，就会一直抛到最外层形成错误，但是这个错误并不会影响或者停止浏览器执行除这个promise之外的其他代码，其实then和catch都会返回一个promise函数让后续继续执行，而参数就是return的内容。所以我们最好的方式就是我们可以在末尾添加一个catch保证错误是能被我们捕获的，然后再添加一个done告诉别人该函数已经执行完毕，我们知道的一个点就是。其实promise在执行完之后会一直保持现有状态，除非后续有调用，否则只有在关掉页面时才会消除。

接着是co+generator的方式实现，生成器是一个带`星号`的"函数"(注意：它并不是真正的函数)，可以通过`yield`关键字`暂停执行`和`恢复执行`的。generator的实现机制主要是靠协程来实现的，协程是一种比线程更加轻量级的存在，一个线程可以有多个协程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。所以在生成器中可以通过yield交出线程执行权，通过return，将线程执行权交回。利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。

最后是async+await的方式实现，这是 ES7 中新增的关键字，凡是加上 async 的函数都默认返回一个 Promise 对象，而更重要的是 async + await 也能让异步代码以同步的方式来书写，而不需要借助第三方库的支持。

而async和await其实可以理解为进阶版的generate，async和await会自动执行，其实就是每一次都会把剩余部分都放到微任务队中等待下次的执行，并且会返回await后的内容。

所以其实promise与async其实都会把后续部分放入到微任务中，而原本的callback其实就是一个宏任务的简易调用。



其实际应该是generate函数、promise函数的应用以及asyn和await的应用了。

对于generate函数其实就是一个函数内，利用yield定义一连串的状态机，然后手动的去执行，也就是用next执行下一个步骤，而next可以传参进去替代原本的yeild的位置。

# 8.vdom

虚拟dom其实就是用js对象模拟dom树，主要是为了解决浏览器性能问题，好处就是页面的更新可以先全部反应在js对象上，等更新完成，再将js对象映射成真实的dom，交给浏览器去绘制。如果有事件发生修改了虚拟dom，那么会比较前后的虚拟dom，得到patch，然后把patch应用到真实的dom上。

1. 用JS对象模拟DOM（虚拟DOM）
2. 把此虚拟DOM转成真实DOM并插入页面中（render）
3. 如果有事件发生修改了虚拟DOM，比较两棵虚拟DOM树的差异，得到差异对象（diff）
4. 把差异对象应用到真正的DOM树上（patch）

每一个dom节点都有tagName、props、children的属性，children数组里面的每一个元素又是一个dom或者字符串，字符串的话说明是文本节点。





# 9.es6





# 10.vue





## 基础

### JavaScript基础

- 常用设计模式
- 装箱 / 拆箱 & 类型转换
- 常用位运算
- 原型
    - __proto__与prototype
    - Object.prototype
    - Function与Object
- 闭包
    - 实现
    - 应用
    - 原理
    - 经典问题(`setTimeout` `IIFE` `let`)
- 执行上下文 调用栈 作用域链
    - 变量对象(VO)与活动对象(AO)
- 继承
    - 寄生组合式继承(组合+原型)
- 事件循环
    - 浏览器UI渲染与事件循环?
    - async与await
    - Promise/A+规范
        - 立即resolved的Promise执行时机
- 垃圾收集
    - 标记清除
    - 引用计数
        - 循环引用如何处理?
- this
    - 作用 & 意义
    - 隐式丢失
    - 优先级
    - 箭头函数的this
- 对象冻结
    - freeze
    - seal
- Object.defineProperties() 与 descriptor
- 模块化
    - ES Modules与CommonJS差异
    - 对循环引用的处理
- 其他
    - caller / callee
    - typeof 与 Instanceof 原理
        - tyoeof null? (机器码)
    - 柯里化
        - 尾递归
    - 类数组
    - isNaN 和 Number.isNaN
    - Obejct.is()漏洞
        - React 使用的 `shallowEqual()` 对其进行的增强

### HTML&CSS

- 语义化
- SEO
- DTD `<!DOCTYPE>`
- W3C与WHATWG
- Html5新增API
- DOM/BOM API
- 常见布局
- 优先级
- 伪类与伪元素
- 预处理器与后处理器
- 盒模型
- CSS3动画
    - GPU加速原理
- 定位
    - 文档流
    - sticky
- src & href
- Flex
- Grid
- Rem与em
- Flexible.js思路
- BFC / IFC
- 水平 / 垂直 / 水平垂直居中
- Prefix
- reset与normalize.css
- 移动端
    - 像素比
    - 检测横屏
    - 图片模糊问题
    - IOS橡皮筋问题
    - 视口类型
    - Vw Vh
    - 1Px

### 基础手写/算法

- ajax
- bind / call / apply
- debounce / throttle
- instanceof
- 深浅拷贝
- promise
- lazy man
- new
- 用setTimeout实现setInterval
- 继承
    - 实现ES6 Class实质的继承
- 冒泡 / 快排 / 选择 ...
- 观察者与发布订阅模式

### ES6

- ES6的Class实质, 与ES5继承异同?
    - Babel编译结果
    - 为什么先`super()`?
- Generator
    - 协程
    - yield
    - co模块
    - Thunk函数
- Iterator
    - for...of
- Symbol
    - 常用的内置接口
- ES6 Module与CommonJS
- Promise
    - 回调函数延迟绑定
    - 错误穿透
    - 状态机制
- Async/Await 的原理
- Decorator
- Proxy
    - 为什么Vue抛弃了Object.defineProperty
    - 元编程
    - 常用方法
- Reflect
    - 为什么需要它?
    - 与Proxy的结合
- map set
    - map与对象互转
    - set与数组互转
    - weakMap weakSet
- 其他新增API
- 关于TC39的标准制定过程
    - Strawman
    - Proposal
    - Draft
    - Canidate
    - Finished
- ES 7/8/9/10 /...
    - 可选链
    - null判断
    - 私有变量
    - ...

### Node

- 优缺点 适用场景
- Node创建子进程的方式
    - spawn
    - exec
    - execFile
    - fork
- npm install
    - dedupe
- Buffer
- Stream
- Node的适用场景及原因
- V8内存管理
    - 新生代与老生代机制
        - From空间与To空间
    - 标记清除与标记整理
        - 触发点
    - 增量标记
- Cluster & IPC
    - child_progress
    - 主从模式
- Node异步I/O & 进程池 & Libuv
- 事件循环
    - timer
    - I/O
    - Idle prepare
    - poll
        - 阻塞
    - check
    - close CB
    - 每一阶段均有的nextTick与microTask
- Koa
    - vs Express?
    - 中间件原理 与 洋葱模型

### 浏览器

- 跨域与跨站
- 强缓存与协商缓存
    - 优先级
    - 请求与响应中的缓存相关请求头
    - E-tag 与 Last-Modified
- 从输入URL到页面呈现
    - 页面渲染中的不良现象
        - 白屏
        - FOUC
    - 图层树 绘制指令 绘制列表
        - 显示提升
        - 隐式提升(层爆炸)
    - 栅格化线程池 位图
    - 重绘 回流
    - DOM树与CSSOM树建树过程
        - 令牌化->建树
        - 样式收集
    - 阻塞
        - js & dom
        - css & js
        - async & defer
- 操作DOM为什么慢
    - 互斥
- cookie / session / token
    - Chrome80默认cookie samesite属性为Lax, 造成的影响?
        - 如何解决兼容性
    - 双令牌机制
    - cookie session_id
    - jwt机理
- 本地存储
- service worker
- requesAnimationFrame
- requestIdleCallback
- 事件机制
    - 委托发生的阶段
    - IE的事件模型
    - 阻止事件与冒泡
    - addEventListener & useCapture
- RESTFul规范
- 跨域
    - JSONP 原理
    - Nginx 原理
    - CORS
        - Options预检
        - 简单 / 复杂 请求
        - 相关字段
- 前端路由原理
    - hash
        - onHashChange
    - history
        - pushState
        - replaceState
        - onPopState
- XSS
    - 文档型 & 反射型 & 存储型
    - httpOnly
    - 转义
    - CSP
- XSRF
    - GET型 POST型 链接类型
    - 同源检测
        - origin
        - referer
    - axios的XSRF防御手段
    - samesite
- Fetch & XHR对比
    - cookie
    - abort
    - onProgress

### 数据库

- 脏读 / 幻读 / 不可重复读
- 事务及边界
- 索引

### 网络

- 七层与五层模型
- DNS查找机制
    - CDN CNAME
- http1.1 -> http1
    - 身份认证
    - 断点续传(206状态码)
    - 缓存
    - keep-alive
- http2 -> http1.1
    - 多路复用
    - 头部压缩
    - server-push
- https 会话层机制?
    - 浏览器内置CA链
- TCP 握手/挥手 过程中出错?
- 泛洪攻击
    - RST包
- TCP/UDP适用场景
    - QUIC协议
    - 为什么DNS使用UDP
- TCP拥塞控制
    - 慢启动 & 拥塞避免
    - 快速重传 & 快速恢复
- 正向代理与反向代理
- Get与Post区别
    - 幂等性

## 进阶

### 框架及工具

#### TypeScript

- type & interface
- 泛型
- 工具类型
- 类型守护
- 装饰器 / IOC

#### Git

- git fetch
- git rebase
- git merge
- git reset
    - hard
    - soft
    - mixed
- git revert

#### Webpack & Parcel

- compiler与compilation
- HMR原理
- 工作流程
- Loader
    - 以Babel-Loader为例
- Plugin
    - 事件流模型
- 性能调优
    - 打包速率
    - 打包大小
    - 打包交互友好度
- 异同

#### React

- Immutable.JS
- 生命周期
    - WillMount x
    - render
    - DidMount
        - 为什么数据获取要在这里? 而不是WillMount?
    - WillReceiveProps x
    - shouldComponentUpdate
    - WillUpdate x
    - render
    - DidUpdate x
    - 以下为新增
    - getDerivedStateFromProps
    - getSnapshotBeforeUpdate
    - getDerivedStateFromError
        - 与componentDidCatch如何搭配
- 为什么要废弃掉这几个生命周期?
    - 为什么getDerivedStateFromProps是静态方法
- Hooks
    - useEffect
    - useState
    - forwardRef & useRef & useImperativeHandle
- Fiber
    - requestIdleCallback
    - 机制
    - reconciliation / commit
- Redux
    - 中间件原理
- setState
    - 原生事件->同步, 合成事件->异步, 为什么?
- React实现的事件机制
- V-Dom与Diff
    - 时间复杂度
- 与Vue的比较
    - 约束 / 迎合
    - 思想

#### Vue

- MVVM原理
    - Observer
    - Compile
    - Watcher

### 业务场景

- 白屏问题排查
- 骨架屏
- 超长列表
    - requesAnimationFrame
    - 虚拟列表
- 单点登录(SSO)
- 埋点的原理
- 扫码登陆
- 大文件分片/完整性校验/断点续传/秒传/拖拽上传/粘贴上传

### 小程序

- 基础架构
- properties / data
- behavior
- DOM BOM如何禁止访问的?
- 生命周期
- 性能优化
- **vs PWA / H5 / Hybrid / 各种跨端方案**

## 漫谈

### 测试

- 单元测试
- E2E
- 混沌

### 工程化

- 错误监控
- 性能优化
- 脚手架
- 埋点
    - SPA应用
    - Hybrid应用
- GraphQL & BFF & Apollo
    - vs RESTFul 优劣势
    - BFF意义, 解决了什么问题?
        - 接口清洗 聚合 ...
        - 带来的新问题
        - Serverless协作
    - Apollo生态圈的主要package
- CI / CD, 自动化构建流程解决了什么问题?
- Serverless
    - FaaS
    - BaaS
    - 小程序云函数思路
- 前端趋势
    - 智能化
    - 跨端
        - 5G 物联网
        - Flutter 与 RN此类方案
        - 演进
    - 价值
        - 向后端侵袭
        - 对业务更熟悉
- 工程化
    - 模块化
        - 以React为例, 你的组件模块化思路?
        - 项目开发模块化
    - 规范化
        - 各种各样的Lint
        - CR
        - 测试
        - ...
    - 系统化
        - 微服务
        - Serverless
        - 中间层
        - ...







# 字节面试题

## 1.HTML、CSS

+ Flex:1是什么意思
+ 实现垂直居中
+ 居中对齐
+ positon 布局有哪些，分别讲讲对他的理解
+ 盒模型
+ 伪类伪元素,css3新增
+ 清除浮动
+ bfc
+ CSS的尺寸单位，分别介绍一下；移动端适配可以用哪些单位？
+ 容器高度是宽度的两倍 多种写法
+ 单行和多行的css省略号 如何判断一行汉字有没有出现省略号







## 2.JS

+ 块级作用域和变量提升

+ 函数有变量提升吗？

+ 普通函数和箭头函数区别

+ `==和===`

+ 如何判断一个对象是NaN

+ js原型和原型链 继承

+ js的数组有哪些方法？Array.prototype.sort()底层实现？

+ js如何去除字符串前后的空格

+ JavaScript 数据类型以及 typeof 返回值。

    + 如何区分[]和{}    

    - Object.prototype.toString.call(obj) ===Object.prototype.toString.call([])

+ 事件代理

    ~~~HTML
    <table id="table" data-xxx="aa">
        <td className="td">
            <div className="target">
                <div>xx</div>
                <div className="warapper">xx</div>
            </div>
        </td>
        ...
    </table>
    ~~~

    target && currentTarget

+ JS深拷贝浅拷贝

+ 手写函数柯里化

+ 遍历对象属性的方法以及区别(三种)

+ 判断是数组的方法（instanceof与Array.isarray）实现instanceof

+ 说说闭包

+ 基本数据类型有啥

+ this指向

+ for of、for in

+ dom事件流，事件监听在什么阶段触发？dom上直接设置onclick跟addeventlistener的区别





## 3.计网

+ http请求头中有哪些内容
+ 说说get 和 post post 有哪几种方法 option 有啥用
+ sessionStorage和localStorage区别
+ 说下cookie
+ http与https 说下非对称加密
+ 说说http状态码 说说http头 502与503区别 304状态码
+ Cookie为啥不安全，怎么防范
+ tcp三次握手 四次挥手 精确到数据包 Tcp udp区别 tcp怎么实现可靠性的
+ 说说cookie  以及它涉及的网络安全问题 是由后台设置吗 前端可以设置吗 如果不想让前端设置呢 cookie的缺点
+ OSI7层模型
+ xss和csrf
+ dns劫持
+ http2.0



## 4.通信

+ promise底层原理
+  Promise被调用后再次调用情况
+ CORS跨域 Content-type有啥 带cookie
+ josnp
+ 异步处理的方法promise callback
+ 实现ajax ajax原理







## 5.VUE

+ Vue实现双向数据绑定的原理，能手写吗 手写vue框架observe源码

+ v-if和v-for能不能写在同一个标签中？（能，但会造成性能问题）

+ v-if和v-show的区别

+ 说说Vue的生命周期

+ 项目有用到vuex吗？如果没有vuex该如何跨多个组件管理状态？

+ vue兄弟组件间传递事件

+ vue和react区别

+ vue-router的两种模式以及区别(hash模式与history模式)

+ vue组件通信

+ 介绍一下vuex以及使用场景；更改state的方法

+ 什么是MVVM，MVC和MVVM的区别

+ 概述下前端整个体系

+ vue的组件化、模块化、工程化的理解

    组件化：一个vue文件就是一个组件。页面上的每个独立的、可视/可交互区域视为一个组件；  

    模块化的话：一个文件既能实现复用也能分而治之。 

    工程化就是动态的HTML,CSSS,JS分离出来，将前端当成工程进行分析，组织和构建从而达到项目结构清晰，分工明确，团队配合默契，开发效率高等目的。

+ 





## 6.webpack







## 7.浏览器

+ 事件循环，宏任务与微任务
+ 输入网址到返回网页的过程（我讲了dns和浏览器渲染过程，面试官追问ip怎么变成mac，要不要变成mac，然后在我一通奇奇怪怪的解释后，小哥哥又觉得他问题表述有点问题，就稀里糊涂的过了这个问题）
+ 浏览器缓存
+ 浏览器存储方式
+ 浏览器本地储存etag和last modified谁优先级高
+ storge介绍一下，有什么区别？和cookie的区别是什么？cookie的字段介绍一下；介绍一下同源策略
+  回流 重绘









## 8.算法

- 手写一下快速排序 插入排序

- 查找第一个缺失的正整数

- M个array，长度分别是 v1、v2、v3 ... vm，从每个 array 各取 1 个元素，试打印出全部的组合方式。

    ```JS
    let  arr = [[1, 2], [1, 2, 3], ]
    // 111,121,131,211,221,231
    ```

- 手写根据输入输出推理栈结构

- 求字符串全排列

- 实现二叉排序树并中序遍历它

- 找很多数中的第K大数（排序，分治），让我实现一个分治

- 给一个数组num，里面全是0和正整数，一开始在num[0]的位置，当前脚下的这个num[i]说明了你最多往前跳的距离，求能否到达数组结尾，能到达的话求最小步数

- 判断两棵二叉树是否完全一致，递归

- 合并区间

- 连续子数组最大值

- 最小连续大于某数的子数组长度

- 分饼算法

- 36进制加法

- 斐波那契实现

- 和大于等于x的最短子序列

- 用 Javascript 构造一个双向链表，并且实现它的插入和删除方法

- 给定一个字符串如下，请统计字符串中出现最多的字母和次数

- 括号生成(22)

- 大数相加

- 二叉树第k小的节点





## 9.智力题

+ 概率题 高中概率题水平
+ 7个试管有一个有毒，至少要多少个兔子才能试出来？应该是4个吧
+ 智力题64匹马，8个赛道，找最快的四匹



## 10.手写

+ 手写图片懒加载

+ Promise.all实现

+ reduce实现

+ 数组去重

+ 判断A，B数组包含关系，A包含于B，返回1，B包含于A，返回2，A，B相等返回0，A，B没有关系返回-1。我用every和includes做出来了，面试官说不用这些方法能做吗？

+ 闭包实现不定参数sum

+ EventEmitter的实现。要求：两个方法on(eventname,callback),trigger(eventname,params)，on绑定可以给eventname绑定多个callback，trigger触发eventname的callback，params是参数。另外口述了如何实现once功能（callback只允许调用一次）

+ 设计一个类似百度搜索框那样随输随搜的，有哪些注意点

+ 实现`I am ${name}, ​${age} years old', {name: 'xiaoming', age: 2}`

+ 实现如下get 函数

    ~~~JS
    const o = {
      a:{
        b:{
          c:1
        }
      }
    }
    get(o,'a.b.c')  //1
    ~~~

+ 数组扁平

+ 基于promise实现jsonp



## 11.项目

+ 项目难点 再说一个难点





秋招：

1. 拼多多 8.2笔试 8.22 下午3点面试

2. 网易云音乐/杭研 8.8笔试 8.15 7点20视频面试

3. 贝壳找房 8.11笔试 评测还未做 8.16 10点视频面试

4. 阿里 8.23 7点面试

5. 腾讯 8.23 8点笔试

6. 招银网络科技

7. 跟谁学

8. 老虎集团

9. 58集团

10. 作业帮

11. 深信服

12. 好未来 

13. 瑛太莱

14. 吉比特

15. 牛客网

16. 搜狗

17. 极米科技

18. 猿辅导

19. 快手

20. 百度

21. 度小满

22. 欢聚YY

23. 美图

24. 网龙网络公司

25. 广联达

26. 中国有赞

27. 西山居游戏（剑侠

28. 小红书

    