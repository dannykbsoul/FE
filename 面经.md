字节面试题准备：

- 关于数据类型转换的规则
- 异步 cb=>iterator=>generator=>promise=>async、await
- 柯里化 compose 类型题

准备好合适的问题问面试官：

- 整个小组的大概运行模式是怎样的
- 整个项目的后续规划是如何的
- 为什么会选择某些技术？标准？
- 我对某个技术很感兴趣，在你的小组中我会有怎么样的机会深入

京东日常：

- 双向数据绑定原理
- vue3.0 新特性以及为什么用这个新特性，为什么升级
- http2 新特性 tcp udp 区别
- webpack 有没有配过
- js 轮询机制 js 下和 node 环境下
- treeshaking 原理
- http 状态码

目前已投递

- 360 笔试 3.25 一面挂
- 奇安信 笔试 3.28
- 平安科技 简历不通过
- 成都超有爱 笔试
- 虎牙
- 商汤科技
- 深圳锐明
- 百度 3.29 笔试 二面结束
- 网易互联网 云音乐 3.31 一面 挂
- 网易雷火 4.25(1:00-2:30) 面试时间 5.9 放弃
- 蘑菇街
- 网易互娱 笔试
- 美团 4.23 笔试 5.6 11 点
- 京东 笔试 4.18 过
- 小米 4.16 投递
- 快手 5.2 前测评 笔试 4.26(4:00-6:00)
- 拼多多 放弃面试

暂时不急着投递的

- 跟谁学
- 头条
- 爱奇艺
- 陌陌 4.30
- 携程
- 作业帮
- 招银网络
- 深信服
- oppo
- 酷家乐
- 百度日常实习
- 顺丰

## 面经

网易云音乐一面：

- 语义化标签
- position 取值 relative 的作用
- flex 布局 alian-self
- 发布订阅模式
- 父子组件传值
- 树的前序遍历 递归非递归
- var let const
- event loop
- webpack 中 js 用啥 loader
- location history
- 深拷贝 浅拷贝
- 数据类型
- 原型
- 盒模型
- call、apply、bind
- 介绍下 Object.defineProperty()
- 生命周期 以及 组件更新调用哪个

360 一面：

- html 语义化 自己用过哪些语义化标签
- 选择器 以及优先级 组合
- 数组去重 sort 事件复杂度
- var let const
- symbol 遍历的方法
- 遍历对象的方法
- flex 布局中 margin 实现水平垂直居中
- 水平垂直居中
- 三角形
- 变量提升 var function 等
- 绑定事件的方法 如何解绑事件
- js 数据类型
- symbol 的创建和其他类型创建的区别
- 状态码
- 伪类、伪元素 有哪些状态
- 数组常用实例方法 splice 参数问题

百度：

一面：

- 说一下 doctype 都用过哪些 doctype

- 说下 promise，async await
- xss csrf xss 有哪些攻击方式 csrf 如何避免 cookie 携带 如何设置让前端通过 js 的方式拿不到 cookie，cookie 是前端生成的吗
- 三栏布局 左右 100px，中间自适应
- 状态码
- 缓存
- 递归 说下如何优化
- 闭包 以及缺陷
- 用过哪些 loader，给你个 scss 文件如何配置 webpack，用过 url-loader 吗？是干嘛的 babel-loader 是干嘛的
- js 垃圾回收机制
- linux 指令 复制一个文件到另一个
- 说下 git 的指令
- 说一下继承 class new 发生了啥
- 如何判断对象是空 如何获取到对象的属性
- 说一下 slice splice
- 实现拖拽窗口
- 如何清除浮动
- BFC 如何创建 BFC
- 说一下模块化
- em 和 rem
- call、apply、bind 的区别

二面：

- 大数相加 有正、负数呢
- 节流
- 实现一个圆形，四等分，左上角和右下角颜色灰色
- float 有了解吗 float 的兼容性了解
- 说下 position
- 请求重试，如果请求失败三次给提示
- 为啥选 vue，不选 jquery，为啥有 vuex，带来哪些好处 说一下 view modal 层是干嘛的

京东一面：

- 水平垂直居中
- css 实现动画
- js 创建类，对象以及继承
- position
- float 的用处以及如何清除浮动
- 雪碧图以及雪碧图中用到的定位、属性
- 什么是跨域？如何解决跨域问题
- 箭头函数和普通函数的区别
- promise
- 实现一个模板方法，作用类似于 ES6 的==``==，例如：`template('我是${name}, 今年${age}岁', {name: 'Tom', age: 18}) 返回 '我是Tom, 今年18岁'`
- js 实现浅拷贝 类似于 Object.assign(obj1,obj2,[…]) extend(obj)
- vue 组件通信
- vue key 的作用
- 你如何学习前端的

京东二面：

- 介绍下项目
- 说下 vuex 的好处在项目中
- 组件化模块化在项目中的用处
- 双向绑定
- vue3.0 改进之处
- http2.0
- 继承
- this

京东 hr 面：

- 自我介绍
- 说一下实验室的项目
- 怎么做的？学到了什么？后面觉得还能改进吗？
- 为什么选择前端？如何自学？
- 职业规划
- 优缺点
- 为什么选择 jd？
- 啥时候能实习？
- 反问

# 1.缓存

浏览器与服务器通信的方式为应答模式，即是：浏览器发起 HTTP 请求 – 服务器响应该请求，那么
浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识，分为三种情况：

1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求

2. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存，那么此时浏览器会携带该资源的缓存标识，向服务器发送请求，如果此时服务端返回 304，协商缓存生效，说明该资源无更新，那么可以直接去浏览器缓存中获取该请求的结果；如果服务端返回 200，协商缓存失效，此时会将该请求的返回结果和缓存标识存入浏览器缓存中。

   控制协商缓存的字段主要有 Last-Modified / If-Modified-Since 和 Etag / If-None-Match。Last-Modified 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，If-Modified-Since 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为 200；否则则返回 304，代表资源无更新，可继续使用缓存文件。

   Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，If-None-Match 是客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回 304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为 200。

   Etag / If-None-Match 优先级高于 Last-Modified / If-Modified-Since，同时存在则只有 Etag / If-None-Match 生效。

3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果。控制强制缓存的字段分别是 Expires 和 Cache-Control，其中 Cache-Control 优先级比 Expires 高。Expires 是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于 Expires 的值时，直接使用缓存结果。但是也有一定的缺点，原因在于 Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。

   到了 HTTP/1.1，Expire 已经被 Cache-Control 替代，Cache-Control 的取值主要有：

   - public：所有内容都将被缓存（客户端和代理服务器都可缓存）
   - private：所有内容只有客户端可以缓存，Cache-Control 的默认取值
   - no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
   - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
   - max-age=xxx (xxx is numeric)：缓存内容将在 xxx 秒后失效

   **HTTP 响应报文中 expires 的时间值，是一个绝对值，HTTP 响应报文中 Cache-Control 为 max-age=600，是相对值**，所以在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control 相比于 expires 是更好的选择，所以同时存在时，只有 Cache-Control 生效。

   强制缓存优先于协商缓存进行，若强制缓存(Expires 和 Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304，继续使用缓存。

# 2.跨域

协议、域名、端口相同的为同源。

同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。**是浏览器做的努力**

主要限制在几个方面

- Cookie、LocalStorage 和 IndexDB 无法读取
- DOM 无法获得
- AJAX 请求不能发送

前后端如何通信：

- ajax
- websocket
- cors

# 3.http 和 https

http 是超文本传输协议，是一个应用层的协议，由请求和响应构成。http 的特点是无状态，http 通信过程会有请求报文和响应报文，请求报文中有请求行、请求头、空行、请求体组成，请求行主要是由请求方法、请求资源地址和协议版本组成，请求头主要是一些服务器要使用的附加信息，比如说 user-agent、 accept、content-type、connection、if-none-match、if-modified-since 等，请求体就是一些需要传输的数据。响应报文中主要有状态行、响应头、响应体，状态行主要就是状态码、状态信息和协议版本号，响应头主要是一些客户端需要用到的附加信息，如 content-type、last-modified、expires、etag 等，响应体是返回给客户端的文本信息。

请求方法主要有 get、post、put、delete、head，get 和 post 的主要区别有

从用法来说 Get 一般用于无副作用、幂等的场景；Post 多用于有副作用、不幂等的情况

> 冥等的定义：发送 M 和 N 次请求，服务器上资源状态一致。比如说，注册 10 个账号和 11 个账号是不冥等的，对文章进行了 10 次 11 次修改是幂等的，因为前者多了一个账号（资源），后者是更新同一个资源。
>
> 副作用的定义：副作用是指对服务器上资源做改变。比如搜索是无副作用的，但更新是有副作用的。

- get 请求能缓存，post 不行
- GET 在浏览器回退时是无害的，而 POST 会再次提交
- post 比 get 相对安全一点，因为 get 请求的信息都是包含在 url 中，而且会被浏览器记录
- Post 可以通过 request body 来传输比 Get 更多的数据
- URL 有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的
- Post 支持更多的编码类型且不对数据类型限制

常见的状态码有

100 表示服务器收到了请求的初始部分，并且请客户端继续发送。

200 表示服务器成功处理了请求并返回资源，204 表示服务器成功处理了请求，但是没有数据，这个状态通常是 cors 预检发送 options 请求以后，服务端返回的状态码。

301 表示资源永久性重定向，当浏览器收到的 HTTP 状态码为 301 时，下次访问对应网址就直接调整到新的网址，不会再访问原网址，302 是临时重定向，浏览器每次访问都要先去目标网址访问，再重定向到新的网址，304 自从上次请求后，请求的网页未修改过，请客户端使用本地缓存。 服务器返回此响应时，不会返回网页内容。

400 服务器不理解请求的语法，401 未授权，请求要求身份验证，对于那些需要登陆的网页，服务器会返回此响应，403 表示服务器拒绝请求，404 表示服务器上没有找到请求的资源。

500 表示服务端在执行请求时发生了错误，503 表示服务器目前无法使用（由于超载或停机维护）

http 是采用请求响应的模式，并且 http 是基于 tcp 连接的，普通模式时，每一次的请求响应都需要建立一次连接，完成之后断开。当使用 keep-alive，那么客户端与服务端的连接持续有效，即不关闭底层的 tcp 连接，当出现对服务端的后继请求时，keep-alive 避免了重新连接建立和释放的开销。但是，长时间的 TCP 连接容易导致系统资源无效占用，配置不当的 keep-alive 有时比重复利用连接带来的损失还更大。所以，正确设置 keep-alive timeout 时间非常重要。

http/1.1 有了长连接，在此之上产生了管线化，即请求和响应就可以不再是依次交替的了。他可以支持一次性发送多个请求，并一次性接收多个响应。

- 管线化机制通过持久连接完成，仅 HTTP/1.1 支持此技术

- 只有 get 与 head 请求可以进行管线化，POST 有限制
- 初次创建连接时不应该启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议
- 管线化不会影响响应到来的顺序，即响应返回的顺序并未改变

http2.0 是对 http1.0 的改进，相较于 http1.0 更快更高效

1. http2.0 实现了**多路复用**，用**一个 TCP 进行连接共享，一个请求对应一个 id，这样就可以发送多个请求**，接收方通过 id 来响应不同的请求，解决了 http1.0 队首阻塞和连接过多的问题。因为 http2.0**在同一域名不论访问多少文件都只有一个连接**，所以对服务器而言，提升的并发量是很大的。

2. http2.0 引入了**二进制数据帧和流**的概念，**数据拆分成数据帧传输，并进行顺序标识，接收方收到数据后按序组合即可获取正确数据**。这样就可以**并行**传输了，解决了 http1.0 只能串行传输的问题。

3. http2.0**压缩头部**，使**用序号对头部编码，在两端备份索引表，通过对编码进行比较来判断是否需要传输，减少了需要传输的大小**。解决了 http1.0 中头部反复传输资源浪费的问题

4. http2.0 中，服务器可以在客户端某个请求后，**主动推送一些客户端一定需要的资源** 。这样也能减少请求的数目。

当然 http2.0 也不是尽善尽美的，比如说在出现丢包的情况时，需要重新传输，后面的数据也就被阻塞了，但是 http1.0 因为有多个连接，所以不会影响其他连接的传输。这样的话 http2.0 的性能反倒不如 http1.0 了。

http 和 https

1. http 是超文本传输协议，信息是明文传输的，https 则是具有安全性的 ssl 加密传输协议
2. 端口不一样，http 80，https 443
3. http 连接是无状态的，https 协议是由 tls 协议进行了加密，比 http 协议安全
4. https 协议需要 ca 申请证书

tls 作用于表示层

https 同时使用了对称加密和非对称加密，（对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据，非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。）数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，**对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输**。

一个 HTTPS 请求实际上包含了两次 HTTP 传输，具体流程主要是：

1. 客户端向服务器发起 HTTPS 请求，连接到服务器的 443 端口
2. 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
3. 服务器将自己的公钥发送给客户端。
4. 客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么 HTTPS 传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为 client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS 中的第一次 HTTP 请求结束。
5. 客户端会发起 HTTPS 中的第二个 HTTP 请求，将加密之后的客户端密钥发送给服务器。
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7. 然后服务器将加密后的密文发送给客户端。
8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样 HTTPS 中的第二个 HTTP 请求结束，整个 HTTPS 传输完成。

http 是无状态的协议，怎么记录登录状态？

- cookie:服务器通过设置`set-cookie`这个响应头，将 cookie 信息返回给浏览器，浏览器将响应头中的 cookie 信息保存在本地，当下次向服务器发送 HTTP 请求时，浏览器会自动将保存的这些 cookie 信息添加到请求头中。通过 cookie，服务器就会识别出浏览器，从而保证返回的数据是这个用户的。
- session:session 典型使用场景购物车，session 基于 cookie 实现的。存放在服务器的一种用来存放用户数据的类似 HashTable 的结构。浏览器第一次发送请求时，服务器自动生成了 HashTable 和 SessionID 来唯一标识这个 hash 表，并将 sessionID 存放在 cookie 中通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的 sessionID 随着 cookie 发送到服务器上，服务器从请求中提取 sessionID，并和保存的所有 sessionID 进行对比，找到这个用户对应的 hash 表。
- token:常用在接口校验，是服务端生成一串字符串，作为客户端请求的标识，用户第一次登陆后，服务器生成一个 token 并将 token 返回客户端，以后客户端只需要带着 token 请求数据，无需用户名密码。
- token 具体:客户端使用用户名和密码请求登录。服务端收到请求，验证用户名和密码。验证成功后，服务端会生成一个 token，然后把这个 token 发送给客户端。客户端收到 token 后把它存储起来，可以放在 cookie 或者 Local Storage（本地存储）里。客户端每次向服务端发送请求的时候都需要带上服务端发给的 token。服务端收到请求，然后去验证客户端请求里面带着 token，如果验证成功，就向客户端返回请求的数据。

# 4.性能优化

1.第一个是 webpack 的优化，一般来说 webpack 优化从俩方面入手，减少 webpack 的打包时间和让 webpack 打包出来的文件体积更小。

打包后的体积主要通过按需加载、tree shaking、scope hoisting 的方式来缩小。

- 如果说将页面全部打包到同一个 js 文件中，虽然说是请求合并了，但是同样也加载了很多不必要的代码，为了让用户首屏的体验更好，肯定是首屏加载的文件体积越小越好，那么我们可以按需加载，将每个路由页面单独打包为一个文件。
- 还有就是我们打包的时候，会把引用的模块整个打包，但是我们可能只用到了模块的一部分，所以用 tree shaking 可以把模块中我们用不到的 shaking 掉，webpack4 在生产环境下默认开启了 tree shaking，开发环境下要在 optimization 下配置 usedExports：true，当然为了避免一些 tree shaking 带来的影响，我们可以在 package.json 中配置 sideEffects 来说明不需要 tree shaking 的模块。
- optimization 中配置 concatenateModules: true，可以让 webapck 分析出模块之间的依赖关系，尽可能打包出来的模块合并到一个函数中'

打包的时间主要通过 loader、happypack、dllplugin 来优化

- 我们在尽可能的少的模块上应用 loader，可以在 rule 中 include exclude 来优化文件搜索范围，比如说我们可以不用编译 node_modules 中的模块，因为里面都是打包编译过的。这样的话可以加快打包的速度
- 我们还可以将打包编译过的文件缓存起来，下次只需要编译更改后的代码文件即可，`loader: 'babel-loader?cacheDirectory=true'`
- 我们可以给需要打包的文件名加上占位符 contenthash，在打包文件内容有变化时，`contenthash`值会自动变化。当项目重新打包上线的时候，用户只需要更新有变化的代码，而没有变化的直接用本地的缓存
- 另一方面，受限于 node 是单线程的，所以 webpack 打包也是单线程的，特别是在执行 loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了
- 还有就是我们可以通过 dllplugin 将特定的类库提前打包引入，这样可以极大的减少打包类库的次数，只有类库版本更新了，才需要重新打包。公共代码抽离成单独文件，在 webpack.dll.js 下对第三方模块单独进行打包，并且通过 dllreferenceplugin 将依赖文件引入项目中

还有就是一些其他小的优化点就是，合理的利用 sourceMap，开发模式建议用`cheap-module-eval-source-map`，提示出来的错误比较全面，同时打包速度也比较快；在生产模式建议用`cheap-module-source-map`，带`inline`_与_`eval`的不能用于生产环境是因为这两者生成的 SourceMap 是内嵌在构建完成的 js 代码中的，会在生产环境直接暴露源代码。

开发环境内存编译。开发环境我们用的 webpackDevServer，打包的时候不会生成 dist 目录，而是将编译生成的文件放到内存中，内存的读取肯定要比硬盘的读取快的多，从而提高开发环境下 webpack 打包的性能。

resolve.extensions 用来表明文件后缀列表，默认查找顺序是 ['.js', '.json']，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面。长度很长的话，意味着每一次查找都需要调用一次文件查找，很影响性能。

resolve.alias 可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径。

2.网络方面

合并资源请求，减少 http 请求，因为浏览器发送 http 请求是有数量限制的，如果一下子发出很多请求，那么后面的请求会等待前面的请求，这样会延长整个页面的加载时间，比如说雪碧图就是将小图标和背景图像合并到一张图片上，然后利用 CSS 的背景定位来显示其中的每一部分，使得使用一个图像文件替代多个小文件成为可能，减少了 http 请求次数。还有就是以 Base64 编码的形式直接写在 html 中，浏览器会识别图片，这样可以不用发送 http 请求，但是大小有限制。

还有就是压缩资源文件大小，可对代码进行压缩，去掉空格、注释、变量替换，在传输时，使用 gzip 等压缩方式也可以降低资源文件的大小。

利用缓存机制，尽可能使用缓存减少请求。

**面对一个具体的缓存需求时，我们到底该怎么决策呢？**

![4](/Users/dannysoul/Desktop/4.png)

当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。

dns prefetch，当你浏览网页的时候，浏览器会在加载网页时对网页中的域名进行解析缓存，当你点击网页中的链接时就无需进行 dns 解析，减少用户等待时间，提高用户体验。还有就是 cookie 的优化，如果在进行同域名的资源请求时，浏览器会默认带上本地的 cookie，这就会带来很大的负担，比如说一个页面加载，会请求很多静态资源，那每一个静态资源的请求都会带上 cookie，事实上静态资源并不需要 cookie 验证。那么我们可以用多域名拆分的方式，将静态资源放在 cdn 域名下，并且考虑到单个域名有并发请求上限，可以考虑使用多个 cdn 域名，并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。

在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载，但不执行，在需要执行的时候执行。当浏览器发现自己需要这些资源时已经为时已晚，所以大多数情况，这些资源的加载都会对页面渲染造成延迟。

可以通过预渲染将下载的文件预先在后台渲染，但是要确保该页面要 100%被打开，否则白白浪费了资源。

最好使用 http2.0，因为 1.0 的时候，每个请求都要重新建立和断开，并且由于 tcp 慢启动的原因，加载体积大的文件很耗时，那么在 2.0 中引入了多路复用，能够让多个请求使用一个 tcp 连接，而且支持 header 压缩，进一步缩小了请求数据的大小

3.浏览器渲染方面

因为浏览器的渲染过程是，浏览器从网络或者磁盘去读取 html 原始字节，并根据文件的编码形式转换成字符串，然后将字符串转换成 token，这些 token 会标记出当前的 token 是开始标签还是结束标签，根据这些 token 创建 dom 节点对象，从而生成了 dom 树，cssom 树的构建和 dom 树的构建相似，这俩个过程是并行的，然后 dom 树和 cssom 树结合，生成渲染树，接着从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标，得到了基于渲染树的布局渲染树，最后再绘制渲染树，这样页面的初次渲染就完成了。之后每当添加新元素到 dom 树上，浏览器都要通过 css 引擎查找 css 样式表，找到符合该元素的样式规则应用到这个元素上，然后再重新去绘制它，查找样式表的规则是从右向左的，所以在写 css 选择器的时候，应该尽量考虑到 css 引擎的方便。

- 避免使用通配符，只对需要用到的元素进行选择。
- 少用标签选择器。
- 减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低

渲染过程中遇到`<script>`就停止渲染，执行 js 代码，因为浏览器中有 gui 渲染线程和 js 引擎线程，为了防止渲染过程中出现不可预期的结果，这俩个线程是互斥的关系。js 的加载执行和解析会阻塞 dom 的构建，所以说如果想要首屏速度快的话，script 标签最好放在底部。同样 css 也会阻塞渲染，就算 dom 树构建完成，也要等到 cssom 树构建完成才能开始渲染，所以一般情况下将 CSS 放在 head 标签里，是为了尽早的构建 cssom 树。

由于 CSS 不会阻塞文档的解析，但是会阻塞文档渲染。把 CSS 放在头部可以先生成 CSSOM 树，后续渲染 DOM 的时候，可以一次性构建 Render 树，只需要渲染一次；如果把 CSS 放在后面，会先解析一次 DOM，加载 CSS 之后，会重新渲染之前的 DOM，需要两次渲染。

- DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片...
- load 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已加载完成

我们可以通过给 script 标签设置加载模式来解决 js 阻塞的问题

- 正常模式下 js 会阻塞浏览器
- async js 不会阻塞浏览器，它的加载是异步的，当加载结束，js 会立即执行
- defer js 加载也是异步的，当整个 html 解析完成，DOMContentLoaded 即将被触发时，js 才会开始执行

一般来说脚本和 dom 元素之间的依赖性不强的时候，用 async，如果脚本依赖于 dom 元素和其他脚本的执行结果时，用 defer

4.dom 优化

js 修改 dom 可能会造成回流和重绘

当我们对 dom 的修改引发了 dom 几何尺寸的变化（修改宽、高、隐藏元素），浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来，这就叫做回流。

当我们对 dom 的修改导致了样式的变化，却未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，叫做重绘。

可以看出重绘不一定导致回流，但是回流一定导致重绘。

比如说想往 div 中写入 10000 句一样的话，使用 document.createDocumentFragment()的虚拟节点对象先把要添加进页面的节点先存起来，然后一次性加到 dom 树里，这样避免了重复的添加导致的回流，很影响性能。

如何避免回流重绘制：

### CSS

- 避免使用`table`布局。
- 尽可能在`DOM`树的最末端改变`class`。
- 避免设置多层内联样式。
- 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上。
- 避免使用`CSS`表达式（例如：`calc()`）。

### JavaScript

- 避免频繁操作样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。
- 避免频繁操作`DOM`，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。
- 也可以先为元素设置`display: none`，操作结束后再把它显示出来。因为在`display`属性为`none`的元素上进行的`DOM`操作不会引发回流和重绘。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

懒加载是针对图片加载时机的优化，在一些图片量比较大的网站，用户打开页面的时候，如果一次性把这个页面所有的图片资源加载完，那么很可能会造成白屏、卡顿的现象，但其实给用户展示的只是一部分，所以可以先把首屏的资源加载完，后面的资源等用户下拉再去请求加载，这样的称为懒加载。

节流和防抖

这两个东西都以**闭包**的形式存在。它们通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，最后用 setTimeout 来控制事件的触发频率。

# 5.tcp 和 udp

# 6.输入 url

# 7.JS

##new 关键字

创建一个全新的对象，这个对象的**proto**指向构造函数的 prototype 属性，将构造函数的 this 替换成新的对象并执行。

##观察者模式和发布订阅模式

发布者直接能触及到订阅者的操作，叫观察者模式，而发布订阅模式，发布者和订阅者是由统一的第三方来完成通信。eventemitter，on 用来订阅事件，并传入回调函数，emit 触发

##深浅拷贝

浅拷贝只会将目标对象的各个属性进行一次复制，但不会递归复制，如果说目标对象第一层为基本数据类型的值，那么就会直接赋值，如果说是引用数据类型的话，那么会直接复制栈内存中的堆内存地址。

深拷贝不只拷贝目标对象的第一层，而是递归拷贝目标对象的所有属性

JSON.stringfy()，所有安全的 JSON 值，都可以用 stringfy 字符串化，不安全的 JSON 值。undefined、function、symbol 和包含循环引用的对象。无法拷贝一些`特殊的对象`，诸如 RegExp, Date, Set, Map 等。

1. 他无法实现对函数 、RegExp 等特殊对象的克隆
2. 会抛弃对象的 constructor,所有的构造函数会指向 Object
3. 对象有循环引用,会报错

## 闭包

闭包是指有权访问另外一个函数作用域中的变量的函数，产生的原因主要是即使创建它的上下文已经销毁，但是它依旧可以通过作用域链存在，当前环境中存在指向父级作用域的引用。

稀疏数组是指 **索引不连续，数组长度大于元素个数的数组**，通俗地说就是 **有空隙的数组**。

转化为密集数组

```js
// 稀疏数组
var a = new Array(5);

Array.apply(null, a); // ES5
Array.from(a); // ES6
```

## 原型和原型链

js 中，每定义一个函数数据类型，都自带 prototype 属性，这个属性指向函数的原型对象，当函数被 new 调用时，这个函数就成了构造函数，返回一个实例对象，这个实例对象有一个`__proto__`属性，它指向了构造函数的原型对象。

每个对象都可以有一个原型*proto*，这个原型还可以有它自己的原型，以此类推，形成一个原型链。查找特定属性的时候，我们先去这个对象里去找，如果没有的话就去它的原型对象里面去，如果还是没有的话再去向原型对象的原型对象里去寻找，这样的一条路径就是原型链。

## 继承

1. 原型链继承：将子类构造函数的 prototype 指向父类的实例对象。

   缺点：因为子类只进行了一次原型修改，所以子类的所有实例都是指向同一父类的值，父类上的引用类型值被所有实例共享，并且在创建子类的时候，不能向父类型的构造函数传递参数。

2. 借用构造函数继承： 在子类构造函数中，使用`父类.call(this)`的方法继承父类属性，相当于在子类的构造函数中将父类构造函数执行一下

   缺点：子类无法继承父类原型链上的属性和方法，并且由于方法在构造函数中定义，每次创建实例都会执行一遍方法

3. 组合继承：使用原型链继承挂在父类原型上的各属性和方法，通过借用构造函数继承写在父类构造函数中 this 上绑定的各属性和方法

   缺点：调用了俩次父类构造函数，造成了不必要的损耗

4. 原型式继承：其实就是 ES5 Object.create 的实现，将传入的参数作为创建的对象的原型。

   缺点：包含引用类型的属性值始终会被共享，和原型链继承一样。

5. 寄生式继承：创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。

   缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。

6. 寄生组合式继承：让子类构造函数的 prototype 指向父类构造函数的 prototype，但是有缺陷

   因为如果我想在子类的 prototype 上添加属性的话，会直接去父类的 prototype 上添加属性，使用 Object.create()，其实就是让子类 prototype 和父类 prototype 中间隔一层对象，子类 prototype 指向这个对象，这个对象的`__proto__`指向父类的 prototype。

   优点：只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。

   ```JS
    function Parent5 () {
       this.name = 'parent5';
       this.play = [1, 2, 3];
     }
     function Child5() {
       Parent5.call(this);
       this.type = 'child5';
     }
   //1. 这一步不用Child.prototype =Parent.prototype的原因是怕共享内存，修改父类原型对象就会影响子类
   //2. 不用Child.prototype = new Parent()的原因是会调用2次父类的构造方法（另一次是call），会存在一份多余的父类实例属性
   //3. Object.create是创建了父类原型的副本，与父类原型完全隔离
     Child5.prototype = Object.create(Parent5.prototype);
     Child5.prototype.constructor = Child5;
   ```

## 类数组对象

拥有一个 length 属性和若干索引属性的对象

- 用 getElementsByTagName/ClassName()获得的 HTMLCollection
- 用 querySelector 获得的 nodeList

类数组转数组：

- Array.prototype.slice.call()

- Array.from()

- ES6 展开运算符 `let args = [...arguments];`

- 利用 concat+apply

  ```JS
  function sum(a, b) {
    let args = Array.prototype.concat.apply([], arguments);//apply方法会把第二个参数展开
    console.log(args.reduce((sum, cur) => sum + cur));//args可以调用数组原生的方法啦
  }
  sum(1, 2);//3
  ```

## 数组中的高阶函数

map

参数:接受两个参数，一个是回调函数，一个是回调函数的 this 值(可选)。其中，回调函数被默认传入三个值，依次为当前元素、当前索引、整个数组。返回一个新的数组。

reduce

参数: 接收两个参数，一个为回调函数，另一个为初始值。回调函数中三个默认参数，依次为积累值、当前值、当前索引、整个数组。

filter

参数: 一个函数参数。这个函数接受一个默认参数，就是当前元素。这个作为参数的函数返回值为一个布尔类型，决定元素是否保留。filter 方法返回值为一个新的数组，这个数组里面包含参数里面所有被保留的项。

sort

参数: 一个用于比较的函数，它有两个默认参数，分别是代表比较的两个元素。

```JS
let nums = [2, 3, 1];
//两个比较的元素分别为a, b
nums.sort(function(a, b) {
  if(a > b) return 1;
  else if(a < b) return -1;
  else if(a == b) return 0;
})
```

当比较函数返回值大于 0，则 a 在 b 的后面，即 a 的下标应该比 b 大。

## this

this 代表函数调用相关联的对象，如果此时作为函数直接调用，非严格模式下，this 指向 window，严格模式下指向 undefined，作为某对象的方法调用时，this 指向调用的对象，使用 call/apply/bind 可以显式绑定 this，构造函数中，this 指向新创建的对象，因为箭头函数没有 this，所以箭头函数的 this 指向当前最近的非箭头函数的 this。

优先级：new>call、apply、bind>对象.方法>直接调用

多次 bind，this 的指向永远由第一次 bind 所决定。

## promise

回调函数=>promise=>co+generator 利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。=>async+await

node 中回调函数的机制，发布订阅模式

promise 为啥解决了回调地狱？

什么是回调地狱：1.多层嵌套的问题 2.每种任务的处理结果存在两种可能性，那么需要在每种任务执行结束后分别处理这两种可能性。

promise 利用了三大技术解决了问题：1.回调函数延迟绑定 2.返回值穿透 3.错误冒泡

## 生成器

生成器是一个带\*的函数，可以通过 yield 关键字暂停执行和恢复执行。

这种暂停执行恢复执行的实现机制主要靠协程，一个线程一次只能执行一个协程，比如说当前执行的 A 协程，另外还有一个 B 协程，如果想要执行 B，那么就必须在 A 中将 js 线程的控制权转交给 B，此时 B 执行，那么 A 就处于暂停状态。协程不是靠操作系统控制的，所以没有进程线程上下文的开销，这是高性能的重要原因。

thunk 函数 这个函数接收一定参数，生成定制化的函数，使用定制化的函数去完成功能。

## js 执行机制

当 js 遇到可执行代码（全局代码、函数代码、eval 代码）的时候，会创建执行上下文，并压入执行上下文栈

js 引擎先会执行全局代码，创建全局上下文，全局上下文被压入执行上下文栈中，每个执行上下文都会有三个重要的属性：变量对象、作用域链、this，一个执行上下文会分为两个阶段，`创建阶段`和`代码执行阶段`，在`创建阶段`，执行上下文会分别创建

1.变量对象：这里的变量对象主要是函数的所有形参（由名称和对应值组成的一个变量对象的属性被创建没有实参，属性值设为 undefined），函数声明，以及变量的声明，在执行阶段会顺序执行代码，根据代码，修改变量对象的值。

2.作用域链：函数的作用域在函数定义的时候就决定了，函数内部有个 scope 属性，是所有父变量对象的层级链，但是此时的 scope 并不是完整的作用域链，当函数执行时，进入函数上下文，创建 vo/ao 对象后，就会将 ao 添加到作用域链的前面，这时候的作用域链是完整的。

this 的指向是在代码执行阶段确定的，默认情况下 this 指向全局对象，比如浏览器中的 window，此外可能存在隐式绑定的情况，比如通过对象调用函数，然后就是显示绑定对象（call apply bind）等，最后优先级最高的就是 new 调用构造函数生成一个对象。

## 事件轮询

event loop 是浏览器或`Node`的一种解决`javaScript`单线程运行时不会阻塞的一种机制，也就是我们经常使用**异步**的原理。

主要是通过一个执行栈和事件队列完成，首先是在执行栈执行全局代码，当遇到诸如 setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)这些宏任务时，会将这些放入宏任务任务队列中，当遇到 process.nextTick、new Promise().then(回调)这些微任务的时候，会将这些放入微任务队列，当执行栈中每执行完一个宏任务，都会去执行微任务队列中的所有微任务，然后再去宏任务队列中去取一个宏任务放入执行栈中，执行宏任务。

node.js 中，

1.先执行全局 script 代码，执行微任务

2.先执行 nextTick queue 中的微任务，再执行其他微任务

3.开始执行宏任务，总共 6 个阶段，从第一个阶段开始执行相应每一个阶段 macrotask 中的所有宏任务

4.Timers Queue -> microtask Queue ->I/O Queue -> microtask Queue -> Check Queue -> microtask Queue -> Close Callback Queue -> microtask Queue -> Timers Queue……

timers 会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。

## 异步的总结

js 的异步其实是为了解决浏览器单线程问题而提出的，如果没有异步，那么浏览器在发送请求的时候就会一直卡死在等待服务器 response 上，从而造成资源利用地下的问题。而异步就是为了解决这个问题，而最早应用的异步应该就是 ajax 里面的回调函数了，但是回调函数依然有问题，那就是如果需要多次应用 callback 就要在里面一层层的添加回调函数从而而造成回调地狱，又或者是如果在多个 ajax 执行完成时才能执行下一步，那可能就需要添加许多额外的变量或者判断。而到了 es6 异步才算是真正的诞生。

首先是 promise，很好了解决了`回调地狱`的问题，以链式调用的方式避免了大量的嵌套，promise 函数可以说是现在应用的最多的一个函数了，我们在平时的开发请求中，也基本会用到它，首先我们知道的是 promise 其实有 3 个状态 pending、fullified、reject，3 种状态，而 3 种状态的转换是不可逆的，promise 的首个状态一般是 pending 也就是在 new Promise 的时候传递进去的函数参数所在的状态就是 pending，要知道的一个点是从 pending 到 fullified 状态其实是需要调用 resolve 参数的，而如果从 pending 到 reject 状态到达的路径有两条，函数内有语法或者数据导致报错，另一条就是手动调用 reject，但是我们有一点需要注意的，对于 promise 的报错是逐渐冒泡的，比如我在 promise 函数内报错，那这个错误就会一直向下冒泡，经历所有的 then 直到后续有 then 的第二个参数或者 catch 对其进行捕获，如果没有，就会一直抛到最外层形成错误，但是这个错误并不会影响或者停止浏览器执行除这个 promise 之外的其他代码，其实 then 和 catch 都会返回一个 promise 函数让后续继续执行，而参数就是 return 的内容。所以我们最好的方式就是我们可以在末尾添加一个 catch 保证错误是能被我们捕获的，然后再添加一个 done 告诉别人该函数已经执行完毕，我们知道的一个点就是。其实 promise 在执行完之后会一直保持现有状态，除非后续有调用，否则只有在关掉页面时才会消除。

接着是 co+generator 的方式实现，生成器是一个带`星号`的"函数"(注意：它并不是真正的函数)，可以通过`yield`关键字`暂停执行`和`恢复执行`的。generator 的实现机制主要是靠协程来实现的，协程是一种比线程更加轻量级的存在，一个线程可以有多个协程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。所以在生成器中可以通过 yield 交出线程执行权，通过 return，将线程执行权交回。利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。

最后是 async+await 的方式实现，这是 ES7 中新增的关键字，凡是加上 async 的函数都默认返回一个 Promise 对象，而更重要的是 async + await 也能让异步代码以同步的方式来书写，而不需要借助第三方库的支持。

而 async 和 await 其实可以理解为进阶版的 generate，async 和 await 会自动执行，其实就是每一次都会把剩余部分都放到微任务队中等待下次的执行，并且会返回 await 后的内容。

所以其实 promise 与 async 其实都会把后续部分放入到微任务中，而原本的 callback 其实就是一个宏任务的简易调用。

其实际应该是 generate 函数、promise 函数的应用以及 asyn 和 await 的应用了。

对于 generate 函数其实就是一个函数内，利用 yield 定义一连串的状态机，然后手动的去执行，也就是用 next 执行下一个步骤，而 next 可以传参进去替代原本的 yeild 的位置。

# 8.vdom

虚拟 dom 其实就是用 js 对象模拟 dom 树，主要是为了解决浏览器性能问题，好处就是页面的更新可以先全部反应在 js 对象上，等更新完成，再将 js 对象映射成真实的 dom，交给浏览器去绘制。如果有事件发生修改了虚拟 dom，那么会比较前后的虚拟 dom，得到 patch，然后把 patch 应用到真实的 dom 上。

1. 用 JS 对象模拟 DOM（虚拟 DOM）
2. 把此虚拟 DOM 转成真实 DOM 并插入页面中（render）
3. 如果有事件发生修改了虚拟 DOM，比较两棵虚拟 DOM 树的差异，得到差异对象（diff）
4. 把差异对象应用到真正的 DOM 树上（patch）

每一个 dom 节点都有 tagName、props、children 的属性，children 数组里面的每一个元素又是一个 dom 或者字符串，字符串的话说明是文本节点。

# 9.es6

# 10.vue

## 基础

### JavaScript 基础

- 常用设计模式
- 装箱 / 拆箱 & 类型转换
- 常用位运算
- 原型
  - **proto**与 prototype
  - Object.prototype
  - Function 与 Object
- 闭包
  - 实现
  - 应用
  - 原理
  - 经典问题(`setTimeout` `IIFE` `let`)
- 执行上下文 调用栈 作用域链
  - 变量对象(VO)与活动对象(AO)
- 继承
  - 寄生组合式继承(组合+原型)
- 事件循环
  - 浏览器 UI 渲染与事件循环?
  - async 与 await
  - Promise/A+规范
    - 立即 resolved 的 Promise 执行时机
- 垃圾收集
  - 标记清除
  - 引用计数
    - 循环引用如何处理?
- this
  - 作用 & 意义
  - 隐式丢失
  - 优先级
  - 箭头函数的 this
- 对象冻结
  - freeze
  - seal
- Object.defineProperties() 与 descriptor
- 模块化
  - ES Modules 与 CommonJS 差异
  - 对循环引用的处理
- 其他
  - caller / callee
  - typeof 与 Instanceof 原理
    - tyoeof null? (机器码)
  - 柯里化
    - 尾递归
  - 类数组
  - isNaN 和 Number.isNaN
  - Obejct.is()漏洞
    - React 使用的 `shallowEqual()` 对其进行的增强

### HTML&CSS

- 语义化
- SEO
- DTD `<!DOCTYPE>`
- W3C 与 WHATWG
- Html5 新增 API
- DOM/BOM API
- 常见布局
- 优先级
- 伪类与伪元素
- 预处理器与后处理器
- 盒模型
- CSS3 动画
  - GPU 加速原理
- 定位
  - 文档流
  - sticky
- src & href
- Flex
- Grid
- Rem 与 em
- Flexible.js 思路
- BFC / IFC
- 水平 / 垂直 / 水平垂直居中
- Prefix
- reset 与 normalize.css
- 移动端
  - 像素比
  - 检测横屏
  - 图片模糊问题
  - IOS 橡皮筋问题
  - 视口类型
  - Vw Vh
  - 1Px

### 基础手写/算法

- ajax
- bind / call / apply
- debounce / throttle
- instanceof
- 深浅拷贝
- promise
- lazy man
- new
- 用 setTimeout 实现 setInterval
- 继承
  - 实现 ES6 Class 实质的继承
- 冒泡 / 快排 / 选择 ...
- 观察者与发布订阅模式

### ES6

- ES6 的 Class 实质, 与 ES5 继承异同?
  - Babel 编译结果
  - 为什么先`super()`?
- Generator
  - 协程
  - yield
  - co 模块
  - Thunk 函数
- Iterator
  - for...of
- Symbol
  - 常用的内置接口
- ES6 Module 与 CommonJS
- Promise
  - 回调函数延迟绑定
  - 错误穿透
  - 状态机制
- Async/Await 的原理
- Decorator
- Proxy
  - 为什么 Vue 抛弃了 Object.defineProperty
  - 元编程
  - 常用方法
- Reflect
  - 为什么需要它?
  - 与 Proxy 的结合
- map set
  - map 与对象互转
  - set 与数组互转
  - weakMap weakSet
- 其他新增 API
- 关于 TC39 的标准制定过程
  - Strawman
  - Proposal
  - Draft
  - Canidate
  - Finished
- ES 7/8/9/10 /...
  - 可选链
  - null 判断
  - 私有变量
  - ...

### Node

- 优缺点 适用场景
- Node 创建子进程的方式
  - spawn
  - exec
  - execFile
  - fork
- npm install
  - dedupe
- Buffer
- Stream
- Node 的适用场景及原因
- V8 内存管理
  - 新生代与老生代机制
    - From 空间与 To 空间
  - 标记清除与标记整理
    - 触发点
  - 增量标记
- Cluster & IPC
  - child_progress
  - 主从模式
- Node 异步 I/O & 进程池 & Libuv
- 事件循环
  - timer
  - I/O
  - Idle prepare
  - poll
    - 阻塞
  - check
  - close CB
  - 每一阶段均有的 nextTick 与 microTask
- Koa
  - vs Express?
  - 中间件原理 与 洋葱模型

### 浏览器

- 跨域与跨站
- 强缓存与协商缓存
  - 优先级
  - 请求与响应中的缓存相关请求头
  - E-tag 与 Last-Modified
- 从输入 URL 到页面呈现
  - 页面渲染中的不良现象
    - 白屏
    - FOUC
  - 图层树 绘制指令 绘制列表
    - 显示提升
    - 隐式提升(层爆炸)
  - 栅格化线程池 位图
  - 重绘 回流
  - DOM 树与 CSSOM 树建树过程
    - 令牌化->建树
    - 样式收集
  - 阻塞
    - js & dom
    - css & js
    - async & defer
- 操作 DOM 为什么慢
  - 互斥
- cookie / session / token
  - Chrome80 默认 cookie samesite 属性为 Lax, 造成的影响?
    - 如何解决兼容性
  - 双令牌机制
  - cookie session_id
  - jwt 机理
- 本地存储
- service worker
- requesAnimationFrame
- requestIdleCallback
- 事件机制
  - 委托发生的阶段
  - IE 的事件模型
  - 阻止事件与冒泡
  - addEventListener & useCapture
- RESTFul 规范
- 跨域
  - JSONP 原理
  - Nginx 原理
  - CORS
    - Options 预检
    - 简单 / 复杂 请求
    - 相关字段
- 前端路由原理
  - hash
    - onHashChange
  - history
    - pushState
    - replaceState
    - onPopState
- XSS
  - 文档型 & 反射型 & 存储型
  - httpOnly
  - 转义
  - CSP
- XSRF
  - GET 型 POST 型 链接类型
  - 同源检测
    - origin
    - referer
  - axios 的 XSRF 防御手段
  - samesite
- Fetch & XHR 对比
  - cookie
  - abort
  - onProgress

### 数据库

- 脏读 / 幻读 / 不可重复读
- 事务及边界
- 索引

### 网络

- 七层与五层模型
- DNS 查找机制
  - CDN CNAME
- http1.1 -> http1
  - 身份认证
  - 断点续传(206 状态码)
  - 缓存
  - keep-alive
- http2 -> http1.1
  - 多路复用
  - 头部压缩
  - server-push
- https 会话层机制?
  - 浏览器内置 CA 链
- TCP 握手/挥手 过程中出错?
- 泛洪攻击
  - RST 包
- TCP/UDP 适用场景
  - QUIC 协议
  - 为什么 DNS 使用 UDP
- TCP 拥塞控制
  - 慢启动 & 拥塞避免
  - 快速重传 & 快速恢复
- 正向代理与反向代理
- Get 与 Post 区别
  - 幂等性

## 进阶

### 框架及工具

#### TypeScript

- type & interface
- 泛型
- 工具类型
- 类型守护
- 装饰器 / IOC

#### Git

- git fetch
- git rebase
- git merge
- git reset
  - hard
  - soft
  - mixed
- git revert

#### Webpack & Parcel

- compiler 与 compilation
- HMR 原理
- 工作流程
- Loader
  - 以 Babel-Loader 为例
- Plugin
  - 事件流模型
- 性能调优
  - 打包速率
  - 打包大小
  - 打包交互友好度
- 异同

#### React

- Immutable.JS
- 生命周期
  - WillMount x
  - render
  - DidMount
    - 为什么数据获取要在这里? 而不是 WillMount?
  - WillReceiveProps x
  - shouldComponentUpdate
  - WillUpdate x
  - render
  - DidUpdate x
  - 以下为新增
  - getDerivedStateFromProps
  - getSnapshotBeforeUpdate
  - getDerivedStateFromError
    - 与 componentDidCatch 如何搭配
- 为什么要废弃掉这几个生命周期?
  - 为什么 getDerivedStateFromProps 是静态方法
- Hooks
  - useEffect
  - useState
  - forwardRef & useRef & useImperativeHandle
- Fiber
  - requestIdleCallback
  - 机制
  - reconciliation / commit
- Redux
  - 中间件原理
- setState
  - 原生事件->同步, 合成事件->异步, 为什么?
- React 实现的事件机制
- V-Dom 与 Diff
  - 时间复杂度
- 与 Vue 的比较
  - 约束 / 迎合
  - 思想

#### Vue

- MVVM 原理
  - Observer
  - Compile
  - Watcher

### 业务场景

- 白屏问题排查
- 骨架屏
- 超长列表
  - requesAnimationFrame
  - 虚拟列表
- 单点登录(SSO)
- 埋点的原理
- 扫码登陆
- 大文件分片/完整性校验/断点续传/秒传/拖拽上传/粘贴上传

### 小程序

- 基础架构
- properties / data
- behavior
- DOM BOM 如何禁止访问的?
- 生命周期
- 性能优化
- **vs PWA / H5 / Hybrid / 各种跨端方案**

## 漫谈

### 测试

- 单元测试
- E2E
- 混沌

### 工程化

- 错误监控
- 性能优化
- 脚手架
- 埋点
  - SPA 应用
  - Hybrid 应用
- GraphQL & BFF & Apollo
  - vs RESTFul 优劣势
  - BFF 意义, 解决了什么问题?
    - 接口清洗 聚合 ...
    - 带来的新问题
    - Serverless 协作
  - Apollo 生态圈的主要 package
- CI / CD, 自动化构建流程解决了什么问题?
- Serverless
  - FaaS
  - BaaS
  - 小程序云函数思路
- 前端趋势
  - 智能化
  - 跨端
    - 5G 物联网
    - Flutter 与 RN 此类方案
    - 演进
  - 价值
    - 向后端侵袭
    - 对业务更熟悉
- 工程化
  - 模块化
    - 以 React 为例, 你的组件模块化思路?
    - 项目开发模块化
  - 规范化
    - 各种各样的 Lint
    - CR
    - 测试
    - ...
  - 系统化
    - 微服务
    - Serverless
    - 中间层
    - ...

# 字节面试题

## 1.HTML、CSS

- Flex:1 是什么意思
- 实现垂直居中
- 居中对齐
- positon 布局有哪些，分别讲讲对他的理解
- 盒模型
- 伪类伪元素,css3 新增
- 清除浮动
- bfc
- CSS 的尺寸单位，分别介绍一下；移动端适配可以用哪些单位？
- 容器高度是宽度的两倍 多种写法
- 单行和多行的 css 省略号 如何判断一行汉字有没有出现省略号

## 2.JS

- 块级作用域和变量提升

- 函数有变量提升吗？

- 普通函数和箭头函数区别

- `==和===`

- 如何判断一个对象是 NaN

- js 原型和原型链 继承

- js 的数组有哪些方法？Array.prototype.sort()底层实现？

- js 如何去除字符串前后的空格

- JavaScript 数据类型以及 typeof 返回值。

  - 如何区分[]和{}

  * Object.prototype.toString.call(obj) ===Object.prototype.toString.call([])

- 事件代理

  ```HTML
  <table id="table" data-xxx="aa">
      <td className="td">
          <div className="target">
              <div>xx</div>
              <div className="warapper">xx</div>
          </div>
      </td>
      ...
  </table>
  ```

  target && currentTarget

- JS 深拷贝浅拷贝

- 手写函数柯里化

- 遍历对象属性的方法以及区别(三种)

- 判断是数组的方法（instanceof 与 Array.isarray）实现 instanceof

- 说说闭包

- 基本数据类型有啥

- this 指向

- for of、for in

- dom 事件流，事件监听在什么阶段触发？dom 上直接设置 onclick 跟 addeventlistener 的区别

## 3.计网

- http 请求头中有哪些内容
- 说说 get 和 post post 有哪几种方法 option 有啥用
- sessionStorage 和 localStorage 区别
- 说下 cookie
- http 与 https 说下非对称加密
- 说说 http 状态码 说说 http 头 502 与 503 区别 304 状态码
- Cookie 为啥不安全，怎么防范
- tcp 三次握手 四次挥手 精确到数据包 Tcp udp 区别 tcp 怎么实现可靠性的
- 说说 cookie 以及它涉及的网络安全问题 是由后台设置吗 前端可以设置吗 如果不想让前端设置呢 cookie 的缺点
- OSI7 层模型
- xss 和 csrf
- dns 劫持
- http2.0

## 4.通信

- promise 底层原理
- Promise 被调用后再次调用情况
- CORS 跨域 Content-type 有啥 带 cookie
- josnp
- 异步处理的方法 promise callback
- 实现 ajax ajax 原理

## 5.VUE

- Vue 实现双向数据绑定的原理，能手写吗 手写 vue 框架 observe 源码

- v-if 和 v-for 能不能写在同一个标签中？（能，但会造成性能问题）

- v-if 和 v-show 的区别

- 说说 Vue 的生命周期

- 项目有用到 vuex 吗？如果没有 vuex 该如何跨多个组件管理状态？

- vue 兄弟组件间传递事件

- vue 和 react 区别

- vue-router 的两种模式以及区别(hash 模式与 history 模式)

- vue 组件通信

- 介绍一下 vuex 以及使用场景；更改 state 的方法

- 什么是 MVVM，MVC 和 MVVM 的区别

- 概述下前端整个体系

- vue 的组件化、模块化、工程化的理解

  组件化：一个 vue 文件就是一个组件。页面上的每个独立的、可视/可交互区域视为一个组件；

  模块化的话：一个文件既能实现复用也能分而治之。

  工程化就是动态的 HTML,CSSS,JS 分离出来，将前端当成工程进行分析，组织和构建从而达到项目结构清晰，分工明确，团队配合默契，开发效率高等目的。

-

## 6.webpack

## 7.浏览器

- 事件循环，宏任务与微任务
- 输入网址到返回网页的过程（我讲了 dns 和浏览器渲染过程，面试官追问 ip 怎么变成 mac，要不要变成 mac，然后在我一通奇奇怪怪的解释后，小哥哥又觉得他问题表述有点问题，就稀里糊涂的过了这个问题）
- 浏览器缓存
- 浏览器存储方式
- 浏览器本地储存 etag 和 last modified 谁优先级高
- storge 介绍一下，有什么区别？和 cookie 的区别是什么？cookie 的字段介绍一下；介绍一下同源策略
- 回流 重绘

## 8.算法

- 手写一下快速排序 插入排序

- 查找第一个缺失的正整数

- M 个 array，长度分别是 v1、v2、v3 ... vm，从每个 array 各取 1 个元素，试打印出全部的组合方式。

  ```JS
  let  arr = [[1, 2], [1, 2, 3], ]
  // 111,121,131,211,221,231
  ```

- 手写根据输入输出推理栈结构

- 求字符串全排列

- 实现二叉排序树并中序遍历它

- 找很多数中的第 K 大数（排序，分治），让我实现一个分治

- 给一个数组 num，里面全是 0 和正整数，一开始在 num[0]的位置，当前脚下的这个 num[i]说明了你最多往前跳的距离，求能否到达数组结尾，能到达的话求最小步数

- 判断两棵二叉树是否完全一致，递归

- 合并区间

- 连续子数组最大值

- 最小连续大于某数的子数组长度

- 分饼算法

- 36 进制加法

- 斐波那契实现

- 和大于等于 x 的最短子序列

- 用 Javascript 构造一个双向链表，并且实现它的插入和删除方法

- 给定一个字符串如下，请统计字符串中出现最多的字母和次数

- 括号生成(22)

- 大数相加

- 二叉树第 k 小的节点

## 9.智力题

- 概率题 高中概率题水平
- 7 个试管有一个有毒，至少要多少个兔子才能试出来？应该是 4 个吧
- 智力题 64 匹马，8 个赛道，找最快的四匹

## 10.手写

- 手写图片懒加载

- Promise.all 实现

- reduce 实现

- 数组去重

- 判断 A，B 数组包含关系，A 包含于 B，返回 1，B 包含于 A，返回 2，A，B 相等返回 0，A，B 没有关系返回-1。我用 every 和 includes 做出来了，面试官说不用这些方法能做吗？

- 闭包实现不定参数 sum

- EventEmitter 的实现。要求：两个方法 on(eventname,callback),trigger(eventname,params)，on 绑定可以给 eventname 绑定多个 callback，trigger 触发 eventname 的 callback，params 是参数。另外口述了如何实现 once 功能（callback 只允许调用一次）

- 设计一个类似百度搜索框那样随输随搜的，有哪些注意点

- 实现`I am ${name}, ${age} years old', {name: 'xiaoming', age: 2}`

- 实现如下 get 函数

  ```JS
  const o = {
    a:{
      b:{
        c:1
      }
    }
  }
  get(o,'a.b.c')  //1
  ```

- 数组扁平

- 基于 promise 实现 jsonp

## 11.项目

- 项目难点 再说一个难点

秋招：

1. 拼多多 8.2 笔试 8.22 下午 3 点面试
2. 网易云音乐/杭研 8.8 笔试 8.15 7 点 20 视频面试
3. 贝壳找房 8.11 笔试 评测还未做 8.16 10 点视频面试
4. 阿里 8.23 7 点面试
5. 腾讯 8.23 8 点笔试
6. 京东
7. 招银网络科技
8. 跟谁学
9. 老虎集团 笔试完
10. 58 集团
11. 作业帮
12. 深信服
13. 好未来
14. 瑛太莱
15. 吉比特 8月27日 20:30-22:30笔试
16. 牛客网 笔试
17. 搜狗
18. 极米科技
19. 猿辅导
20. 快手
21. 百度
22. 度小满
23. 欢聚 YY
24. 美图
25. 网龙网络公司
26. 广联达
27. 中国有赞
28. 西山居游戏（剑侠
29. 小红书

拼多多一面 8.22：

1. setTimeout、setInterval 的区别，以及返回值，setTimeout 实现 setInterval
2. 接着问如果在执行过程中暂停之前的定时器(闭包)
3. 给定对象和属性名数组，删除对象上对应的属性
4. 数组的遍历方法，接着问用 reduce 实现上面的问题
5. 箭头函数和普通函数的区别
6. 普通函数 this 指向问题
7. 函数的作用域在什么时候确定？this 指向呢？
8. 如何遍历对象的属性？(for in),如何去除原型链上的属性
9. 对象浅拷贝、深拷贝？浅拷贝的缺点？如何便捷实现深拷贝？缺点
10. 防抖、节流以及应用场景
11. 动画了解吗？如何让图片一直旋转
12. react 的 dom diff
13. 柯里化说一下？
14. 如何获取到 url 后面的参数

阿里一面 8.23：

1. position 有哪些属性？display？如何让设置了 position:fixed 的元素水平垂直居中？flex 有哪些属性？用 flex 实现垂直居中
2. 实现一个月亮
3. rem 和 px 区别
4. css动画了解多少
5. cookie 和 session，有何区别？如何让分布式的服务器共享 sessionid
6. 服务端如何设置前端的cookie
7. 说一下跨域，如何跨域
8. fetch 说一下，他能实现跨域吗，和ajax的区别
9. 说一下 promise，async 和 await以及实现
10. 有哪些请求方式？get、post。。。说一下 post 和 put 的区别
11. 对于传输的data是json格式的，则 Content-Type 该设置什么
12. 滑动验证登陆的实现
13. 做过客户端吗？比如百度网盘。。。电脑端的
14. pwa？webassemble？
15. chrome插件做过吗？
16. node了解多少
17. 除了js还会哪些语言
18. apply 和 call 的区别
19. 说一下取消事件默认行为和取消冒泡以及它们的区别和设置，举一个取消冒泡的实际应用例子
20. 来写几道题吧。。。三道代码题，分别是异步的输出、自定义排序、输入框筛选数据
21. 说一下 react 如何通信？vue 如何通信？为什么通信用 redux 而不用发布订阅模式
22. 说一下自己对组件的理解
23. hooks 的几个 api说一下
